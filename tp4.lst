P16 assembler v1.3.2 (May  7 2020)	tp4.lst	Sat Jun 18 14:19:32 2022

Sections
Index   Name            Addresses       Size
0       .startup        0000 - 000F     0010 16
1       .text           0010 - 02B7     02A8 680
2       .data           02B8 - 02CA     0013 19
3       .bss            02CC - 02CC     0001 1
4       .stack          02CE - 030D     0040 64

Symbols
Name                    Type      Value      Section
_start                  LABEL     0004 4     .startup
add_score               LABEL     018C 396   .text
BALL_LEDS_MASK          ABSOLUTE  00FE 254   .startup
ball_pos                LABEL     02C4 708   .data
ball_pos_addr           LABEL     0182 386   .text
ball_pos_addr_cc        LABEL     01B8 440   .text
ball_pos_addr_ddd       LABEL     002E 46    .text
ball_pos_addrb          LABEL     0124 292   .text
continue_game           LABEL     0098 152   .text
CPSR_BIT_I              ABSOLUTE  0010 16    .startup
current_lvl_addr        LABEL     0180 384   .text
current_lvl_dificult_in_time LABEL     02BE 702   .data
direction               LABEL     02C9 713   .data
direction_addr          LABEL     0126 294   .text
direction_addr_bb       LABEL     01B6 438   .text
direction_addr_cc       LABEL     003E 62    .text
end_inport_test_bit     LABEL     0264 612   .text
end_inport_test_bit_1   LABEL     0262 610   .text
finish_mov              LABEL     01B0 432   .text
game_loop               LABEL     005A 90    .text
game_over               LABEL     00C0 192   .text
game_over_loop          LABEL     00CC 204   .text
get_ball_position       LABEL     011E 286   .text
get_direction           LABEL     0118 280   .text
get_level_dif           LABEL     015C 348   .text
get_score               LABEL     0184 388   .text
get_timer_1s            LABEL     0132 306   .text
get_timer_5s            LABEL     0144 324   .text
get_timer_lvl           LABEL     0156 342   .text
IE_MASK                 ABSOLUTE  0010 16    .startup
init_timer_1s           LABEL     0128 296   .text
init_timer_5s           LABEL     013A 314   .text
init_timer_lvl          LABEL     014C 332   .text
INPORT_ADDRESS          ABSOLUTE  FF00 65280 .startup
inport_address_local    LABEL     026E 622   .text
inport_read             LABEL     0268 616   .text
inport_test_bits        LABEL     0250 592   .text
invert_dir              LABEL     010A 266   .text
isr                     LABEL     01BA 442   .text
isr_addr                LABEL     000E 14    .startup
LED0_MASK               ABSOLUTE  0001 1     .startup
LEVEL_INPUT_MASK        ABSOLUTE  00C0 192   .startup
level_up_skip           LABEL     00A6 166   .text
lvl_in_time             LABEL     02C5 709   .data
lvl_list_addr           LABEL     017E 382   .text
LVL_MASK                ABSOLUTE  00C0 192   .startup
main                    LABEL     0032 50    .text
main_addr               LABEL     000C 12    .startup
main_while              LABEL     0040 64    .text
mov_away                LABEL     01AE 430   .text
mov_ball                LABEL     019A 410   .text
new_point_led           LABEL     02C8 712   .data
new_point_led_addr      LABEL     00DA 218   .text
new_point_led_addrbbb   LABEL     00FC 252   .text
NEW_POINT_LED_MASK      ABSOLUTE  0001 1     .startup
one_second_pass         LABEL     00DE 222   .text
one_second_pass_spik    LABEL     006A 106   .text
outport_addr            LABEL     02B6 694   .text
OUTPORT_ADDRESS         ABSOLUTE  FF00 65280 .startup
outport_clear_bits      LABEL     028A 650   .text
outport_img             LABEL     02CC 716   .bss
outport_img_address     LABEL     02B4 692   .text
outport_init            LABEL     0270 624   .text
OUTPORT_INIT_VALUE      ABSOLUTE  0000 0     .startup
outport_set_bits        LABEL     027C 636   .text
outport_write           LABEL     02AE 686   .text
outport_write_bits      LABEL     029A 666   .text
PLAYER_MASK             ABSOLUTE  0080 128   .startup
ptc_addr                LABEL     021C 540   .text
pTC_ADDRESS             ABSOLUTE  FF40 65344 .startup
pTC_CMD_START           ABSOLUTE  0000 0     .startup
pTC_CMD_STOP            ABSOLUTE  0001 1     .startup
pTC_TC                  ABSOLUTE  0004 4     .startup
pTC_TCR                 ABSOLUTE  0000 0     .startup
pTC_TIR                 ABSOLUTE  0006 6     .startup
pTC_TMR                 ABSOLUTE  0002 2     .startup
PTC_VALUE               ABSOLUTE  0032 50    .startup
RAKET_MASK              ABSOLUTE  0001 1     .startup
reset_all               LABEL     023A 570   .text
score                   LABEL     02C0 704   .data
score_addr              LABEL     00DC 220   .text
score_addr_bb           LABEL     0198 408   .text
score_addr_reset        LABEL     024E 590   .text
set_ball_leds           LABEL     00FE 254   .text
set_led_newpoint        LABEL     00EE 238   .text
set_level_dif           LABEL     0162 354   .text
skip_invert_dir         LABEL     00A0 160   .text
STACK_SIZE              ABSOLUTE  0040 64    .startup
start_game              LABEL     004E 78    .text
sw_is_pressed           LABEL     021E 542   .text
sw_is_pressed_0         LABEL     0234 564   .text
sw_is_pressed_1         LABEL     0236 566   .text
sw_state                LABEL     02CA 714   .data
sw_state_address        LABEL     0238 568   .text
SYS_init                LABEL     0010 16    .text
sysclk_elapsed          LABEL     01E6 486   .text
sysclk_get_value        LABEL     01E0 480   .text
ticks                   LABEL     02C2 706   .data
ticks_addr              LABEL     01EE 494   .text
ticks_addr_reset        LABEL     024C 588   .text
ticks_addrb             LABEL     0030 48    .text
time_lvl                LABEL     0080 128   .text
timer_1s                LABEL     02BA 698   .data
timer_1s_adrr           LABEL     00EC 236   .text
timer_1s_adrrb          LABEL     0138 312   .text
timer_1s_adrrvv         LABEL     00D8 216   .text
timer_5s                LABEL     02BC 700   .data
timer_5s_adrrb          LABEL     014A 330   .text
timer_addressr          LABEL     01DE 478   .text
timer_addressrc         LABEL     0200 512   .text
timer_clearInterrupt    LABEL     01D6 470   .text
timer_init              LABEL     020A 522   .text
timer_level             LABEL     02B8 696   .data
timer_level_adrr        LABEL     00EA 234   .text
timer_level_adrrb       LABEL     017C 380   .text
timer_start             LABEL     01F0 496   .text
timer_stop              LABEL     0202 514   .text
timer_write             LABEL     01F8 504   .text
tos                     LABEL     030E 782   .stack
tos_addr                LABEL     000A 10    .startup
VALU_OF_1S              ABSOLUTE  0014 20    .startup
VALU_OF_25              ABSOLUTE  0005 5     .startup
VALU_OF_5S              ABSOLUTE  0064 100   .startup
VARIANT_LEVEL           ABSOLUTE  0003 3     .startup
wait_for_init_stroke    LABEL     0044 68    .text
WALL_MASK               ABSOLUTE  0002 2     .startup

Code listing
   1           	
   2           	; Autor:     Manuel Fonseca   n: 48052
   3           	; Autor:	 Manuel Henriques n: 47202
   4           	; Autor:	 Tiago Pardal 	  n: 47206
   5           	
   6           	
   7           	
   8           	
   9           	; Definicao dos valores dos simbolos utilizados no programa
  10           	; valores calculados para o pico timer ligado a 1khz
  11           	
  12          		.equ	STACK_SIZE, 64           ; Dimensao do stack (em bytes)
  13           	
  14          		.equ    INPORT_ADDRESS, 0xFF00  ; Endereço do porto de entrada da placa SDP16
  15          		.equ	OUTPORT_ADDRESS, 0xFF00 ; Endereço do porto de saida da placa SDP16
  16           	
  17          		.equ	CPSR_BIT_I, 0x10          ; Mascara para a flag I do registo CPSR
  18          		.equ	PTC_VALUE, 50			; Intervalo de contagem do circuito pTC ; valores calculados para o pico timer ligado a 1khz
  19           		
  20           	                                        ; que suporta a implementação do sysclk
  21           											; fin_pTC = 1kHz fout_ptc=20Hz => T=50ms 
  22           											
  23          		.equ 	LED0_MASK, 0x01
  24          		.equ 	OUTPORT_INIT_VALUE, 0x00
  25           	
  26          		.equ 	IE_MASK,0x10
  27           	
  28          		.equ    pTC_ADDRESS, 0XFF40
  29          		.equ    pTC_TCR, 0
  30          		.equ    pTC_TMR, 2
  31          		.equ    pTC_TC,  4
  32          		.equ    pTC_TIR, 6
  33           		
  34          		.equ    pTC_CMD_STOP,  1
  35          		.equ    pTC_CMD_START, 0
  36           	
  37          		.equ 	PLAYER_MASK, 0X80
  38          		.equ	WALL_MASK,   0X02
  39          		.equ 	NEW_POINT_LED_MASK, 0X1
  40          		.equ	LEVEL_INPUT_MASK, 0xc0
  41          		.equ	BALL_LEDS_MASK, 0xfe
  42          		.equ 	RAKET_MASK, 0x01
  43          		.equ 	LVL_MASK, 0xc0
  44          		.equ	VALU_OF_1S, 20		;0.05 * 20 = 1s
  45          		.equ	VALU_OF_5S, 100		;0.05 * 100 = 5s
  46          		.equ	VALU_OF_25, 5		;0.05 * 5 = 2.5s
  47           	
  48          		.equ	VARIANT_LEVEL, 3
  49           	
  50           	; Seccao:    .startup
  51           	; Descricao: Guarda o código de arranque do sistema
  52           	;
  53           		.section .startup
  54 0000 01 58		b 	_start
  55 0002 5F 0C		ldr	pc, isr_addr
  56           	
  57           	_start:
  58 0004 2D 0C		ldr sp, tos_addr
  59 0006 04 5C		bl SYS_init
  60 0008 1F 0C		ldr	pc, main_addr
  61           	
  62           	tos_addr:
  63 000A 0E 03		.word	tos
  64           	main_addr:
  65 000C 32 00		.word	main
  66           	isr_addr:
  67 000E BA 01		.word	isr
  68           		
  69           	;----------------------------------------	
  70           	;# define OUTPORT_INIT_VALUE 0
  71           	;# define LED0_MASK 1
  72           	;
  73           	;uint16_t ticks = 0;
  74           	; 
  75           	;void main() {
  76           	;uint16_t t;
  77           	;	outport_init ( OUTPORT_INIT_VALUE );
  78           	;	timer_init ( SYSCLK_FREQ );
  79           	;   //Habilitar o atendimento das interrupcoes
  80           	;   while(1) {
  81           	;		outport_set_bits(LED0_MASK);
  82           	;		t = sysclk_get_value ();
  83           	;		while ( sysclk_elapsed ( t ) < LED_TOGGLE_TIME );
  84           	;		outport_clear_bits(LED0_MASK);
  85           	;		t = sysclk_get_value ();
  86           	;		while ( sysclk_elapsed ( t ) < LED_TOGGLE_TIME );
  87           	;   }
  88           	;}
  89           	;----------------------------------------	
  90           		.text
  91           	SYS_init:
  92 0010 0E 24		push lr
  93 0012 2E 5D		bl outport_init		
  94 0014 F6 5C		bl timer_stop
  95 0016 C0 0C		ldr		r0, ticks_addrb
  96 0018 01 00		ldr		r1, [r0, #0]
  97 001A 01 60		mov		r1,  #0
  98 001C 01 20		str		r1, [r0, #0]
  99 001E 00 68		mov r0, 0x80
 100 0020 61 0C		ldr r1, ball_pos_addr_ddd
 101 0022 10 28		strb r0, [r1]
 102           		
 103 0024 20 63		mov r0, PTC_VALUE
 104 0026 F1 5C		bl timer_init		
 105           	
 106 0028 00 61		mov r0, IE_MASK
 107 002A 40 B0		msr cpsr, r0	
 108 002C 0F 04		pop pc	
 109           		
 110           	ball_pos_addr_ddd:
 111 002E C4 02		.word 	ball_pos	
 112           		
 113           	ticks_addrb:
 114 0030 C2 02		.word ticks
 115           	
 116           	main:
 117 0032 0E 24		push lr	
 118 0034 E6 5C		bl timer_stop
 119 0036 30 0C		ldr r0, direction_addr_cc
 120 0038 01 60		mov r1, 0
 121 003A 01 28		strb r1, [r0]
 122 003C 01 58		b main_while
 123           		
 124           	direction_addr_cc:
 125 003E C9 02		.word	direction
 126           		
 127           	main_while:
 128 0040 5E 5C		bl set_ball_leds
 129 0042 FB 5C		bl reset_all
 130           		
 131           	wait_for_init_stroke:
 132 0044 10 60		mov r0, RAKET_MASK
 133 0046 EB 5C		bl sw_is_pressed
 134 0048 00 A0		add r0,r0,0
 135 004A 01 44		bzc start_game  
 136 004C FB 5B		b    wait_for_init_stroke
 137           		
 138           	start_game:
 139 004E 89 5C		bl set_level_dif
 140 0050 CF 5C		bl timer_start
 141 0052 7C 5C		bl init_timer_lvl
 142 0054 69 5C		bl init_timer_1s
 143 0056 A1 5C		bl mov_ball
 144 0058 52 5C		bl set_ball_leds
 145           	
 146           	game_loop:
 147 005A 10 60		mov r0, RAKET_MASK
 148 005C E0 5C		bl sw_is_pressed
 149 005E 69 5C		bl get_timer_1s
 150 0060 C2 5C		bl sysclk_elapsed
 151 0062 41 61		mov r1, VALU_OF_1S
 152 0064 80 B8		cmp r0, r1 ;20
 153 0066 01 48		blo one_second_pass_spik
 154 0068 3A 5C		bl one_second_pass
 155           	
 156           	one_second_pass_spik:	
 157 006A 70 0F		ldr r0, new_point_led_addr
 158 006C 00 08		ldrb r0,[r0]
 159 006E 00 A8		sub r0,r0,0
 160 0070 07 40		bzs time_lvl
 161           		
 162 0072 5F 5C		bl get_timer_1s
 163 0074 B8 5C		bl sysclk_elapsed
 164 0076 51 60		mov r1, VALU_OF_25
 165 0078 80 B8		cmp r0, r1 ;20
 166 007A 02 48		blo	time_lvl	
 167 007C 00 60		mov r0, 0
 168 007E 37 5C		bl set_led_newpoint
 169           		
 170           	time_lvl:
 171 0080 6A 5C		bl get_timer_lvl
 172 0082 B1 5C		bl sysclk_elapsed
 173 0084 01 B0		mov r1, r0
 174 0086 6A 5C		bl get_level_dif
 175 0088 10 B8		cmp r1, r0
 176 008A 0D 48		blo level_up_skip
 177           		
 178 008C 5F 5C		bl init_timer_lvl 
 179 008E 47 5C		bl get_ball_position
 180 0090 02 68		mov r2, PLAYER_MASK
 181 0092 00 89		sub r0, r0, r2
 182 0094 01 44		bzc continue_game
 183 0096 14 58		b game_over
 184           		
 185           	continue_game:
 186 0098 42 5C		bl get_ball_position
 187 009A 00 A9		sub r0, r0, WALL_MASK
 188 009C 01 44		bzc skip_invert_dir
 189 009E 35 5C		bl invert_dir
 190           		
 191           	skip_invert_dir:
 192 00A0 7C 5C		bl mov_ball
 193 00A2 2D 5C		bl set_ball_leds
 194 00A4 53 5C		bl init_timer_lvl
 195           		
 196           	level_up_skip:	
 197           		;ball in wall ?
 198           		;ball in player? 
 199 00A6 3B 5C		bl get_ball_position
 200 00A8 02 68		mov r2, PLAYER_MASK
 201 00AA 00 89		sub r0, r0, r2	
 202 00AC D6 47		bzc game_loop
 203           		;raket? 
 204 00AE 10 60		mov r0, RAKET_MASK
 205 00B0 B6 5C		bl sw_is_pressed
 206 00B2 00 A0		add r0,r0,0
 207 00B4 D2 43		bzs  game_loop
 208           		
 209 00B6 29 5C		bl invert_dir
 210 00B8 49 5C		bl init_timer_lvl	
 211 00BA 6F 5C		bl mov_ball
 212 00BC 20 5C		bl set_ball_leds
 213           		
 214 00BE CD 5B		b game_loop
 215           		
 216           	game_over:
 217 00C0 24 5C		bl invert_dir
 218 00C2 E3 5C		bl outport_clear_bits
 219 00C4 5F 5C		bl get_score
 220 00C6 DA 5C		bl outport_set_bits
 221 00C8 38 5C		bl init_timer_5s
 222 00CA 44 66		mov r4, VALU_OF_5S
 223           		
 224           	;wait 5s
 225           	game_over_loop:
 226 00CC 3B 5C		bl get_timer_5s
 227 00CE 8B 5C		bl sysclk_elapsed
 228 00D0 00 BA		cmp r0, r4
 229 00D2 FC 4B		blo game_over_loop
 230 00D4 96 5C		bl timer_stop
 231 00D6 B4 5B		b  main_while 	
 232           		
 233           	timer_1s_adrrvv:
 234 00D8 BA 02		.word 	timer_1s
 235           	
 236           	new_point_led_addr:
 237 00DA C8 02		.word 	new_point_led
 238           		
 239           	score_addr:
 240 00DC C0 02		.word 	score
 241           		
 242           	one_second_pass:
 243           		;SCORE ++
 244           		;LED ON NEW POINT
 245           		;INIT TIMER
 246 00DE 0E 24		push lr
 247 00E0 23 5C		bl init_timer_1s
 248 00E2 10 60		mov r0, 1
 249 00E4 04 5C		bl set_led_newpoint
 250 00E6 52 5C		bl add_score
 251 00E8 0F 04		pop pc
 252           		
 253           		
 254           	timer_level_adrr:
 255 00EA B8 02		.word timer_level
 256           	
 257           	timer_1s_adrr:
 258 00EC BA 02		.word 	timer_1s	
 259           		
 260           		
 261           	; set led new point to the valu of r0	
 262           	set_led_newpoint:
 263 00EE 0E 24		push lr
 264 00F0 51 0C		ldr r1, new_point_led_addrbbb
 265 00F2 10 28		strb r0, [r1]
 266 00F4 01 B0		mov r1,r0
 267 00F6 10 60		mov r0, NEW_POINT_LED_MASK
 268 00F8 D0 5C		bl	outport_write_bits
 269 00FA 0F 04		pop pc
 270           		
 271           	new_point_led_addrbbb:
 272 00FC C8 02			.word	new_point_led
 273           	
 274           	
 275           	/*
 276           		---------------------------------------	Ball Releated Functions ---------------------------------------
 277           	*/
 278           	
 279           	set_ball_leds:
 280 00FE 0E 24		push lr	
 281 0100 11 0D		ldr	r1, ball_pos_addrb
 282 0102 11 08		ldrb r1, [r1]
 283 0104 E0 6F		mov r0, BALL_LEDS_MASK
 284 0106 C9 5C		bl	outport_write_bits	
 285 0108 0F 04		pop pc
 286           	
 287           	invert_dir:
 288 010A 0E 24		push lr
 289 010C C0 0C		ldr r0, direction_addr
 290 010E 01 08		ldrb r1, [r0]
 291 0110 12 60		mov r2, 1
 292 0112 11 D1		eor r1, r1, r2
 293 0114 01 28		strb r1, [r0]
 294 0116 0F 04		pop pc
 295           	
 296           	get_direction:
 297 0118 60 0C		ldr r0, direction_addr
 298 011A 00 08		ldrb r0, [r0]
 299 011C 0F B7		mov pc, lr
 300           	
 301           	get_ball_position:
 302 011E 20 0C		ldr r0, ball_pos_addrb
 303 0120 00 08		ldrb r0, [r0]
 304 0122 0F B7		mov pc, lr
 305           	
 306           	ball_pos_addrb:
 307 0124 C4 02		.word 	ball_pos
 308           	
 309           	direction_addr:
 310 0126 C9 02		.word	direction
 311           	
 312           	/*
 313           		---------------------------------------	1s Timer Releated Functions ---------------------------------------
 314           	*/
 315           	
 316           	init_timer_1s:
 317 0128 0E 24		push lr
 318 012A 5A 5C		bl sysclk_get_value	
 319 012C 51 0C		ldr r1, timer_1s_adrrb
 320 012E 10 20		str r0, [r1]	
 321 0130 0F 04		pop pc
 322           	
 323           	get_timer_1s:
 324 0132 20 0C		ldr r0, timer_1s_adrrb
 325 0134 00 00		ldr r0, [r0]
 326 0136 0F B7		mov pc, lr
 327           		
 328           	timer_1s_adrrb:
 329 0138 BA 02		.word 	timer_1s
 330           	
 331           	/*
 332           		---------------------------------------	5s Timer Releated Functions ---------------------------------------
 333           	*/
 334           	
 335           	init_timer_5s:
 336 013A 0E 24		push lr
 337 013C 51 5C		bl sysclk_get_value	
 338 013E 51 0C		ldr r1, timer_5s_adrrb
 339 0140 10 20		str r0, [r1]	
 340 0142 0F 04		pop pc
 341           	
 342           	get_timer_5s:
 343 0144 20 0C		ldr r0, timer_5s_adrrb
 344 0146 00 00		ldr r0, [r0]
 345 0148 0F B7		mov pc, lr
 346           		
 347           	timer_5s_adrrb:
 348 014A BC 02		.word 	timer_5s
 349           	/*
 350           		---------------------------------------	Level Releated Functions ---------------------------------------
 351           	*/
 352           	
 353           	init_timer_lvl:
 354 014C 0E 24		push lr
 355 014E 48 5C		bl sysclk_get_value	
 356 0150 51 0D		ldr r1, timer_level_adrrb
 357 0152 10 20		str r0, [r1]	
 358 0154 0F 04		pop pc
 359           	
 360           	get_timer_lvl:
 361 0156 20 0D		ldr r0, timer_level_adrrb
 362 0158 00 00		ldr r0, [r0]
 363 015A 0F B7		mov pc, lr
 364           	
 365           	get_level_dif:
 366 015C 10 0D		ldr r0, current_lvl_addr
 367 015E 00 08		ldrb r0, [r0] 
 368 0160 0F B7		mov pc, lr
 369           		
 370           	set_level_dif:
 371 0162 0E 24		push lr
 372 0164 81 5C		bl inport_read
 373 0166 01 6C		mov r1, LEVEL_INPUT_MASK
 374 0168 10 C0		and r0, r1, r0
 375 016A 00 EB		lsr r0, r0, #6
 376 016C 31 60		mov r1, VARIANT_LEVEL
 377 016E 80 B8		cmp r0, r1
 378 0170 F8 43		beq set_level_dif //TODO
 379           	
 380 0172 51 0C		ldr r1, lvl_list_addr
 381 0174 10 18		ldrb r0, [r1, r0]	//lvl_list + input lvl as offset
 382 0176 41 0C		ldr r1, current_lvl_addr
 383 0178 10 28		strb r0, [r1]
 384 017A 0F 04		pop pc
 385           	
 386           	
 387           	timer_level_adrrb:
 388 017C B8 02		.word timer_level
 389           	
 390           	lvl_list_addr:
 391 017E C5 02		.word lvl_in_time
 392           	
 393           	current_lvl_addr:
 394 0180 BE 02		.word current_lvl_dificult_in_time
 395           	
 396           	/*
 397           		-------------------------------------------------------------------------------------------------------
 398           	*/
 399           	
 400           	ball_pos_addr:
 401 0182 C4 02		.word 	ball_pos
 402           		
 403           	get_score:
 404 0184 0E 24		push lr
 405 0186 81 0C		ldr r1, score_addr_bb
 406 0188 10 00		ldr r0, [r1]
 407 018A 0F 04		pop pc
 408           		
 409           	add_score:	
 410 018C 0E 24		push lr
 411 018E 40 0C		ldr r0, score_addr_bb
 412 0190 01 00		ldr r1, [r0]
 413 0192 91 A0		add r1, r1, 1
 414 0194 01 20		str r1, [r0]
 415 0196 0F 04		pop pc
 416           		
 417           		
 418           	score_addr_bb:
 419 0198 C0 02		.word score
 420           	;-------------------------------------------------------------------------
 421           	; Rotina:    mov_ball
 422           	; Descricao: R
 423           	; Entradas:  -
 424           	; Saidas:    -
 425           	; Efeitos:   Move bola em função de direção
 426           	;			  Na direção do player ou da parede
 427           	; void mov_ball() {
 428           	;   
 429           	;}	
 430           	mov_ball:
 431 019A 0E 24		push lr
 432 019C BD 5F		bl get_direction
 433 019E 01 B0		mov r1, r0
 434 01A0 BE 5F		bl get_ball_position
 435 01A2 12 60		mov r2, 1
 436 01A4 11 C1		and r1,r1,r2
 437 01A6 11 A8		sub r1, r1, 0	
 438 01A8 02 40		bzs mov_away
 439           		;move from wall to player (BALL_POS6)01 -> (BALL_POS0)07   
 440 01AA 80 E0		lsl r0, r0,1	
 441 01AC 01 58		b finish_mov
 442           	mov_away:
 443 01AE 80 E8		lsr r0, r0,1
 444           		
 445           	finish_mov:
 446 01B0 31 0C		ldr r1, ball_pos_addr_cc
 447 01B2 10 28		strb r0, [r1]
 448 01B4 0F 04		pop pc
 449           		
 450           		
 451           	direction_addr_bb:
 452 01B6 C9 02		.word direction
 453           		
 454           	ball_pos_addr_cc:
 455 01B8 C4 02			.word ball_pos
 456           	
 457           	;-------------------------------------------------------------------------
 458           	; Rotina:    isr
 459           	; Descricao: Rotina responsavel pelo processamento do pedido de interrupcao.
 460           	; Entradas:  -
 461           	; Saidas:    -
 462           	; Efeitos:   Incrementa o valor da variavel global ticks
 463           	; void isr() {
 464           	;   ticks++;
 465           	;	//clear Interrupt Request
 466           	;}
 467           	isr:
 468           		; Prologo
 469 01BA 00 24		push	r0
 470 01BC 01 24		push	r1
 471 01BE 02 24		push	r2
 472           		; Corpo da rotina
 473 01C0 60 0D		ldr		r0, ticks_addr
 474 01C2 01 00		ldr		r1, [r0, #0]
 475 01C4 91 A0		add		r1, r1, #1
 476 01C6 01 20		str		r1, [r0, #0]
 477           		; clear Interrupt Request
 478 01C8 F1 6F		mov r1, 0xFF
 479 01CA 80 0E		ldr  r0, ptc_addr
 480 01CC 01 2B		strb r1, [ r0, #pTC_TIR ]
 481           		; Epilogo
 482 01CE 02 04		pop		r2
 483 01D0 01 04		pop		r1
 484 01D2 00 04		pop		r0
 485 01D4 20 B0		movs	pc, lr
 486           		
 487           		
 488           	timer_clearInterrupt:
 489 01D6 00 60		mov r0, 0
 490 01D8 21 0C		ldr r1, timer_addressr
 491 01DA 10 2B		strb r0, [ r1, #pTC_TIR ]
 492 01DC 0F B7		mov pc, lr
 493           		
 494           		
 495           	timer_addressr:
 496 01DE 40 FF		.word  pTC_ADDRESS	
 497           	;-------------------------------------------------------------------------
 498           	;Funcao para devolver o valor corrente da variável global ticks.
 499           	;uint16_t sysclk_get_value ( void );
 500           	;	return ticks;
 501           	;-------------------------------------------------------------------------
 502           	sysclk_get_value:
 503 01E0 61 0C		ldr		r1, ticks_addr
 504 01E2 10 00		ldr  	r0, [r1, #0] 	; r0 = ticks
 505 01E4 0F B7		mov		pc, lr
 506           	
 507           	;-------------------------------------------------------------------------
 508           	;Funcao para devolver o tempo decorrido desde o instante last_read. 
 509           	;O tempo e medido em unidades de contagem ( ticks ).
 510           	;uint8_t sysclk_elapsed ( uint16_t last_read ){
 511           	;	return ( ticks - last_read )
 512           	;}
 513           	;-------------------------------------------------------------------------
 514           	sysclk_elapsed:
 515 01E6 31 0C		ldr	 r1, ticks_addr
 516 01E8 12 00		ldr  r2, [r1, #0] 	; r0 = ticks
 517 01EA 20 88		sub  r0, r2, r0
 518 01EC 0F B7		mov  pc,lr
 519           	
 520           	ticks_addr:
 521 01EE C2 02		.word ticks
 522           		
 523           	;-------------------------------------------------------------------------
 524           	;Funcao para iniciar a contagem no periferico.
 525           	;void timer_start ( void );
 526           	;-------------------------------------------------------------------------
 527           	timer_start:
 528 01F0 01 60		mov  r1, #pTC_CMD_START
 529 01F2 40 0D		ldr  r0, ptc_addr
 530 01F4 01 28		strb r1, [ r0, #pTC_TCR ]
 531 01F6 0F B7		mov  pc, lr
 532           	
 533           	
 534           	timer_write:
 535 01F8 32 0C		ldr 	r2, timer_addressrc
 536 01FA 00 80		add		r0, r0, r0
 537 01FC 21 38		strb 	r1, [r2,r0]	
 538 01FE 0F B7		mov		pc,lr
 539           	
 540           	timer_addressrc:
 541 0200 40 FF		.word  pTC_ADDRESS	
 542           	;-------------------------------------------------------------------------
 543           	;Funcao para parar a contagem no periferico. 
 544           	;Colocando o contador com o valor zero.
 545           	;void timer_stop ( void );
 546           	;-------------------------------------------------------------------------
 547           	timer_stop:
 548 0202 11 60		mov  r1, #pTC_CMD_STOP
 549 0204 B0 0C		ldr  r0, ptc_addr
 550 0206 01 28		strb r1, [ r0, #pTC_TCR ]
 551 0208 0F B7		mov  pc, lr
 552           	
 553           	;-------------------------------------------------------------------------
 554           	;Funcao que faz a iniciacao do periferico para habilitar o 
 555           	;funcionamento em modo continuo e com intervalo de contagem 
 556           	;interval, em ticks.
 557           	;void timer_init ( uint8_t interval );
 558           	;-------------------------------------------------------------------------
 559           	timer_init:
 560 020A 0E 24		push lr
 561 020C 00 24		push r0				
 562           		; Parar contagem
 563 020E F9 5F		bl   timer_stop
 564           		; Programar intervalo de contagem
 565 0210 00 04		pop	 r0
 566 0212 41 0C		ldr  r1, ptc_addr
 567 0214 10 29		strb r0, [ r1, #pTC_TMR ]
 568           		; Clear Interrupt Request
 569 0216 21 0C		ldr  r1, ptc_addr
 570 0218 10 2B		strb r0, [ r1, #pTC_TIR ]
 571 021A 0F 04		pop  pc
 572           		
 573           	ptc_addr:
 574 021C 40 FF		.word pTC_ADDRESS
 575           	
 576           	;---------------------------------------------------------------------------------	
 577           	;uint8_t sw_is_pressed(uint8_t pin_mask) {
 578           	;uint8_t sw_new_state;
 579           	;   sw_new_state = inport_test_bits( pin_mask );
 580           	;	if ( sw_state == sw_new_state )
 581           	;		return 0;
 582           	;	sw_state = sw_new_state;
 583           	;   if ( sw_new_state == 0 )
 584           	;		return 0;
 585           	;	return 1;
 586           	;}
 587           	;---------------------------------------------------------------------------------	
 588           	; Rotina:    sw_is_pressed
 589           	; Descricao: 
 590           	; Entradas:  pins_mask
 591           	; Saidas:    devolve 1 se detecta uma transição 0 -> 1 no pino identificado em pin_mask 
 592           	;            e 0 se não detecta.   
 593           	; Efeitos:   
 594           	;---------------------------------------------------------------------------------	
 595           	sw_is_pressed:
 596 021E 0E 24		push	lr
 597 0220 17 5C		bl		inport_test_bits 
 598           		; r0 = sw_new_state = inport_test_bits(pins_mask)
 599 0222 A1 0C		ldr		r1, sw_state_address
 600 0224 12 08		ldrb	r2, [r1, #0]	; r2 = sw_state
 601 0226 00 B9		cmp		r0, r2			; sw_state == sw_new_state
 602 0228 05 40		beq		sw_is_pressed_0
 603 022A 10 28		strb	r0, [r1, #0]	; sw_state = sw_new_state;
 604 022C 00 A8		sub		r0, r0, #0
 605 022E 02 40		beq		sw_is_pressed_0
 606 0230 10 60		mov		r0, #1
 607 0232 01 58		b		sw_is_pressed_1
 608           	sw_is_pressed_0:
 609 0234 00 60		mov		r0, #0
 610           	sw_is_pressed_1:
 611 0236 0F 04		pop		pc
 612           	
 613           	sw_state_address:
 614 0238 CA 02		.word	sw_state
 615           	
 616           	
 617           	reset_all:
 618 023A 0E 24		push	lr
 619 023C E2 5F		bl timer_stop
 620           		;timer sysclk  = 0	
 621 023E 61 0C		ldr		r1, ticks_addr_reset
 622 0240 00 60		mov r0, 0
 623 0242 10 20		str		r0, [r1, #0]	
 624           		
 625 0244 41 0C		ldr		r1, score_addr_reset
 626 0246 00 60		mov r0, 0
 627 0248 10 20		str		r0, [r1, #0]	
 628           		
 629 024A 0F 04		pop		pc
 630           		
 631           	ticks_addr_reset:
 632 024C C2 02		.word 	ticks
 633           		
 634           	score_addr_reset:
 635 024E C0 02		.word	score
 636           	;---------------------------------------------------------------------------------	
 637           	;uint16_t inport_test_bits(uint16_t pins_mask) {
 638           	;	return ((inport_read() & pins_mask) == pins_mask);
 639           	;}
 640           	;---------------------------------------------------------------------------------	
 641           	; Rotina:    inport_test_bits
 642           	; Descricao: Devolve um se todos dos pinos do porto de entrada identificados com o valor um
 643           	; em pins_mask tomaremm o valor logico um , ou zero no caso contrario .
 644           	; Entradas:  Mascara com os bits a testar
 645           	; Saidas:    Devolve um ou zero conforme a descrição.
 646           	; Efeitos:   
 647           	;---------------------------------------------------------------------------------	
 648           	inport_test_bits:
 649 0250 0E 24		push	lr
 650 0252 04 24		push	r4
 651 0254 04 B0		mov		r4, r0
 652 0256 08 5C		bl		inport_read
 653 0258 00 C2		and		r0, r0, r4
 654 025A 00 BA		cmp     r0, r4
 655 025C 02 40		beq		end_inport_test_bit_1
 656 025E 00 60		mov		r0, #0
 657 0260 01 58		b		end_inport_test_bit
 658           	end_inport_test_bit_1:
 659 0262 10 60		mov		r0, #1
 660           	end_inport_test_bit:
 661 0264 04 04		pop		r4
 662 0266 0F 04		pop		pc
 663           		
 664           	;---------------------------------------------------------------------------------	
 665           	;uint16_t inport_read() {
 666           	;	return [INPORT_ADDRESS];
 667           	;}
 668           	;---------------------------------------------------------------------------------	
 669           	; Rotina:    inport_read
 670           	; Descricao: Devolve o valor corrente do estado dos pinos do porto de entrada.
 671           	; Entradas:  
 672           	; Saidas:    Valor corrente do porto
 673           	; Efeitos:   
 674           	;---------------------------------------------------------------------------------	
 675           	inport_read:
 676 0268 20 0C		ldr		r0, inport_address_local
 677 026A 00 08		ldrb	r0, [r0, #0]
 678 026C 0F B7		mov		pc, lr
 679           	
 680           	inport_address_local:
 681 026E 00 FF		.word	INPORT_ADDRESS
 682           	;---------------------------------------------------------------------------------	
 683           	;uint8_t outport_init(uint8_t initial_value) {
 684           	;	outport_img = initial_value;
 685           	;	outport_write(outport_img);
 686           	;}
 687           	;---------------------------------------------------------------------------------	
 688           	; Rotina:    outport_init
 689           	; Descricao: Inicia o porto de saida, atribuindo-lhe o valor do argumento passado 
 690           	;			 a rotina.
 691           	; Entradas:  Valor para iniciar o porto de saida
 692           	; Saidas:    
 693           	; Efeitos:   Atualiza o valor da variavel imagem do porto
 694           	;---------------------------------------------------------------------------------	
 695           	outport_init:
 696 0270 0E 24		push	lr
 697 0272 00 60		mov r0 , #0
 698 0274 F1 0D		ldr		r1, outport_img_address
 699 0276 10 28		strb	r0, [r1, #0]
 700 0278 1A 5C		bl		outport_write
 701 027A 0F 04		pop		pc
 702           	
 703           	;---------------------------------------------------------------------------------	
 704           	;void outport_set_bits(uint8_t pins_mask) {
 705           	;	outport_img |= pins_mask;
 706           	;	ourport_write(outport_img);
 707           	;}
 708           	;---------------------------------------------------------------------------------	
 709           	; Rotina:    outport_set_bits
 710           	; Descricao: Atribui o valor logico '1' aos pinos do porto de saida identificados 
 711           	;			 com o valor 1 no argumento passado a rotina. O estado dos restantes 
 712           	;			 bits nao e alterado.
 713           	; Entradas:  Mascara com os bits a alterar
 714           	; Saidas:    
 715           	; Efeitos:   Atualiza o valor da variavel imagem do porto
 716           	;---------------------------------------------------------------------------------	
 717           	outport_set_bits:
 718 027C 0E 24		push	lr
 719 027E A1 0D		ldr		r1, outport_img_address
 720 0280 12 08		ldrb	r2, [r1, #0]
 721 0282 20 C8		orr		r0, r2, r0
 722 0284 10 28		strb	r0, [r1, #0]
 723 0286 13 5C		bl		outport_write
 724 0288 0F 04		pop		pc
 725           	
 726           	;---------------------------------------------------------------------------------	
 727           	;void outport_clear_bits(uint8_t pins_mask) {
 728           	;	outport_img &= ~pins_mask ;
 729           	;	ourport_write(outport_img);
 730           	;}
 731           	;---------------------------------------------------------------------------------	
 732           	; Rotina:    outport_clear_bits
 733           	; Descricao: Atribui o valor logico '0' aos pinos do porto de saida identificados 
 734           	;			 com o valor 1 no argumento passado a rotina. O estado dos restantes 
 735           	;			 bits nao e alterado.
 736           	; Entradas:  Mascara com os bits a alterar
 737           	; Saidas:    
 738           	; Efeitos:   Atualiza o valor da variavel imagem do porto
 739           	;---------------------------------------------------------------------------------	
 740           	outport_clear_bits:
 741 028A 0E 24		push	lr
 742 028C 31 0D		ldr		r1, outport_img_address
 743 028E 12 08		ldrb	r2, [r1, #0]
 744 0290 10 B0		mvn		r0, r0
 745 0292 20 C0		and		r0, r2, r0
 746 0294 10 28		strb	r0, [r1, #0]
 747 0296 0B 5C		bl		outport_write
 748 0298 0F 04		pop		pc
 749           	
 750           	;---------------------------------------------------------------------------------	
 751           	;void outport_write_bits(uint8_t pins_mask, uint8_t value) {
 752           	;	value &= pins_mask;
 753           	;	outport_img &= ~pins_mask;
 754           	;	outport_img |= value;
 755           	;	ourport_write(outport_img)
 756           	;}
 757           	;---------------------------------------------------------------------------------	
 758           	; Rotina:    outport_write_bits
 759           	; Descricao: Atribui aos pinos do porto de saida identificados com o valor lógico
 760           	;            um em pins_mask o valor dos bits correspondentes de value. O estado 
 761           	;            dos restantes bits nao e alterado.
 762           	; Entradas:  Mascara com os bits a alterar
 763           	;         :  valor dos bits a alterar  
 764           	; Saidas:    
 765           	; Efeitos:   Atualiza o valor da variavel imagem do porto
 766           	;---------------------------------------------------------------------------------	
 767           	outport_write_bits:
 768 029A 0E 24		push	lr
 769 029C 81 C0		and		r1, r0, r1				; r1 = pins_mask & value
 770 029E A2 0C		ldr		r2, outport_img_address
 771 02A0 23 08		ldrb	r3, [r2, #0]
 772 02A2 10 B0		mvn		r0, r0					; ~pins_mask
 773 02A4 33 C0		and		r3, r3, r0				; outport_img &= ~pins_mask;
 774 02A6 B0 C8		orr		r0, r3, r1				; outport_img |= pins_mask & value;
 775 02A8 20 28		strb	r0, [r2, #0]
 776 02AA 01 5C		bl		outport_write
 777 02AC 0F 04		pop		pc
 778           	
 779           	;---------------------------------------------------------------------------------	
 780           	;void outport_write(uint8_t value) {
 781           	;	outport_img = value;
 782           	;	[OUTPORT_ADDRESS] = outport_img;
 783           	;}
 784           	;---------------------------------------------------------------------------------	
 785           	; Rotina:    outport_write
 786           	; Descricao: Atribui aos pinos do porto de saida o valor dos bits correspondentes de value.
 787           	; Entradas:  Valor a escrever no porto
 788           	; Saidas:    
 789           	; Efeitos:   Atualiza o valor da variavel imagem do porto
 790           	;---------------------------------------------------------------------------------	
 791           	outport_write:
 792 02AE 31 0C		ldr		r1, outport_addr
 793 02B0 10 28		strb	r0, [r1, #0]
 794 02B2 0F B7		mov		pc, lr
 795           	
 796           	outport_img_address:
 797 02B4 CC 02		.word	outport_img
 798           	
 799           	outport_addr:
 800 02B6 00 FF		.word	OUTPORT_ADDRESS
 801           		
 802           	; Seccao:    .data
 803           	; Descricao: Guarda as variáveis globais com valor inicial definido
 804           	;
 805           		.data
 806           	timer_level:
 807 02B8 00 00		.word	0
 808           		
 809           	timer_1s:
 810 02BA 00 00		.word	0
 811           		
 812           	timer_5s:
 813 02BC 00 00		.word	0
 814           		
 815           	current_lvl_dificult_in_time:
 816 02BE 0A 00		.word	10
 817           	
 818           	score:
 819 02C0 00 00		.word	0
 820           		
 821           	ticks:
 822 02C2 00 00		.word	0		; uint16_t ticks;
 823           		
 824           	ball_pos:
 825 02C4 80		.byte	0x80
 826           	lvl_in_time:
 827           		.byte	20, 10, 5		; 1s / 0.5s / 0.25s
 827 02C5 14 0A 05
 828           	
 829           	new_point_led:
 830 02C8 00		.byte	0x00
 831           		
 832           	direction: ; 0 away from player 1 into the player
 833 02C9 00		.byte	0x00
 834           	sw_state:
 835 02CA 00		.byte 	0
 836           	; Seccao:    .bss
 837           	; Descricao: Guarda as variáveis globais sem valor inicial definido
 838           	;
 839           		.section .bss
 840           	outport_img:			; Imagem do porto de saida no programa
 841 02CC 00   		.space	1	
 842           	
 843           	; Seccao:    .stack
 844           	; Descricao: Implementa a pilha com o tamanho definido pelo simbolo STACK_SIZE
 845           	;
 846           		.section .stack
 847 02CE 00   		.space STACK_SIZE
 847 .... ..
 847 030D 00
 848           	tos:
