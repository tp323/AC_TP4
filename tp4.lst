P16 assembler v1.3.2 (May  7 2020)	tp4.lst	Sat Jun 18 23:35:05 2022

Sections
Index   Name            Addresses       Size
0       .startup        0000 - 000F     0010 16
1       .text           0010 - 02A7     0298 664
2       .data           02A8 - 02BA     0013 19
3       .bss            02BC - 02BC     0001 1
4       .stack          02BE - 02FD     0040 64

Symbols
Name                    Type      Value      Section
_start                  LABEL     0004 4     .startup
add_score               LABEL     0184 388   .text
await_time_or_player    LABEL     00A6 166   .text
BALL_LEDS_MASK          ABSOLUTE  00FE 254   .startup
ball_pos                LABEL     02B4 692   .data
ball_pos_addr           LABEL     002E 46    .text
ball_pos_addr_ext1      LABEL     011E 286   .text
ball_pos_addr_ext2      LABEL     01AC 428   .text
continue_game           LABEL     00A0 160   .text
CPSR_BIT_I              ABSOLUTE  0010 16    .startup
current_lvl_addr        LABEL     017A 378   .text
current_lvl_dificult_in_time LABEL     02AE 686   .data
direction               LABEL     02B9 697   .data
direction_addr          LABEL     003E 62    .text
direction_addr_ext      LABEL     0120 288   .text
end_inport_test_bit     LABEL     0254 596   .text
end_inport_test_bit_1   LABEL     0252 594   .text
finish_mov              LABEL     01A6 422   .text
game_loop               LABEL     005A 90    .text
game_over               LABEL     00BC 188   .text
game_over_loop          LABEL     00CA 202   .text
get_ball_position       LABEL     0118 280   .text
get_direction           LABEL     0112 274   .text
get_level_dif           LABEL     0156 342   .text
get_score               LABEL     017C 380   .text
get_timer_1s            LABEL     012C 300   .text
get_timer_5s            LABEL     013E 318   .text
get_timer_lvl           LABEL     0150 336   .text
IE_MASK                 ABSOLUTE  0010 16    .startup
init_timer_1s           LABEL     0122 290   .text
init_timer_5s           LABEL     0134 308   .text
init_timer_lvl          LABEL     0146 326   .text
INPORT_ADDRESS          ABSOLUTE  FF00 65280 .startup
inport_address_local    LABEL     025E 606   .text
inport_read             LABEL     0258 600   .text
inport_test_bits        LABEL     0240 576   .text
invert_dir              LABEL     0104 260   .text
isr                     LABEL     01C2 450   .text
isr_addr                LABEL     000E 14    .startup
LED0_MASK               ABSOLUTE  0001 1     .startup
LEVEL_INPUT_MASK        ABSOLUTE  00C0 192   .startup
lvl_in_time             LABEL     02B5 693   .data
lvl_list_addr           LABEL     0178 376   .text
LVL_MASK                ABSOLUTE  00C0 192   .startup
main                    LABEL     0032 50    .text
main_addr               LABEL     000C 12    .startup
main_while              LABEL     0040 64    .text
mov_away                LABEL     01A4 420   .text
mov_ball                LABEL     0190 400   .text
new_point_led           LABEL     02B8 696   .data
new_point_led_addr      LABEL     00DA 218   .text
new_point_led_addr_ext  LABEL     00F6 246   .text
NEW_POINT_LED_MASK      ABSOLUTE  0001 1     .startup
next_move_dir           LABEL     0098 152   .text
one_second_pass         LABEL     00DC 220   .text
one_second_pass_spik    LABEL     006A 106   .text
outport_addr            LABEL     02A6 678   .text
OUTPORT_ADDRESS         ABSOLUTE  FF00 65280 .startup
outport_clear_bits      LABEL     027A 634   .text
outport_img             LABEL     02BC 700   .bss
outport_img_address     LABEL     02A4 676   .text
outport_init            LABEL     0260 608   .text
OUTPORT_INIT_VALUE      ABSOLUTE  0000 0     .startup
outport_set_bits        LABEL     026C 620   .text
outport_write           LABEL     029E 670   .text
outport_write_bits      LABEL     028A 650   .text
PLAYER_MASK             ABSOLUTE  0080 128   .startup
ptc_addr                LABEL     0222 546   .text
pTC_ADDRESS             ABSOLUTE  FF40 65344 .startup
pTC_CMD_START           ABSOLUTE  0000 0     .startup
pTC_CMD_STOP            ABSOLUTE  0001 1     .startup
pTC_TC                  ABSOLUTE  0004 4     .startup
pTC_TCR                 ABSOLUTE  0000 0     .startup
pTC_TIR                 ABSOLUTE  0006 6     .startup
pTC_TMR                 ABSOLUTE  0002 2     .startup
PTC_VALUE               ABSOLUTE  0032 50    .startup
RAKET_MASK              ABSOLUTE  0001 1     .startup
reset_all               LABEL     01AE 430   .text
score                   LABEL     02B0 688   .data
score_addr              LABEL     01C0 448   .text
set_ball_leds           LABEL     00F8 248   .text
set_led_newpoint        LABEL     00E8 232   .text
set_level_dif           LABEL     015C 348   .text
STACK_SIZE              ABSOLUTE  0040 64    .startup
start_game              LABEL     004E 78    .text
sw_is_pressed           LABEL     0224 548   .text
sw_is_pressed_0         LABEL     023A 570   .text
sw_is_pressed_1         LABEL     023C 572   .text
sw_state                LABEL     02BA 698   .data
sw_state_address        LABEL     023E 574   .text
SYS_init                LABEL     0010 16    .text
sysclk_elapsed          LABEL     01EC 492   .text
sysclk_get_value        LABEL     01E6 486   .text
ticks                   LABEL     02B2 690   .data
ticks_addr              LABEL     0030 48    .text
ticks_addr_ext          LABEL     01F4 500   .text
time_lvl                LABEL     0080 128   .text
timer_1s                LABEL     02AA 682   .data
timer_1s_addr           LABEL     0132 306   .text
timer_5s                LABEL     02AC 684   .data
timer_5s_addr           LABEL     0144 324   .text
timer_addr              LABEL     0206 518   .text
timer_clearInterrupt    LABEL     01DE 478   .text
timer_init              LABEL     0210 528   .text
timer_level             LABEL     02A8 680   .data
timer_level_addr        LABEL     0176 374   .text
timer_start             LABEL     01F6 502   .text
timer_stop              LABEL     0208 520   .text
timer_write             LABEL     01FE 510   .text
tos                     LABEL     02FE 766   .stack
tos_addr                LABEL     000A 10    .startup
VALUE_OF_1S             ABSOLUTE  0014 20    .startup
VALUE_OF_25             ABSOLUTE  0005 5     .startup
VALUE_OF_5S             ABSOLUTE  0064 100   .startup
VARIANT_LEVEL           ABSOLUTE  0003 3     .startup
wait_for_init_stroke    LABEL     0044 68    .text
WALL_MASK               ABSOLUTE  0002 2     .startup

Code listing
   1           	
   2           	; Autor:     Manuel Fonseca   n: 48052
   3           	; Autor:	 Manuel Henriques n: 47202
   4           	; Autor:	 Tiago Pardal 	  n: 47206
   5           	
   6           	
   7           	
   8           	
   9           	; Definicao dos valores dos simbolos utilizados no programa
  10           	; valores calculados para o pico timer ligado a 1khz
  11           	
  12          		.equ	STACK_SIZE, 64           ; Dimensao do stack (em bytes)
  13           	
  14          		.equ    INPORT_ADDRESS, 0xFF00  ; Endereço do porto de entrada da placa SDP16
  15          		.equ	OUTPORT_ADDRESS, 0xFF00 ; Endereço do porto de saida da placa SDP16
  16           	
  17          		.equ	CPSR_BIT_I, 0x10          ; Mascara para a flag I do registo CPSR
  18          		.equ	PTC_VALUE, 50			; Intervalo de contagem do circuito pTC ; valores calculados para o pico timer ligado a 1khz
  19           		
  20           	                                        ; que suporta a implementação do sysclk
  21           											; fin_pTC = 1kHz fout_ptc=20Hz => T=50ms 
  22           											
  23          		.equ 	LED0_MASK, 0x01
  24          		.equ 	OUTPORT_INIT_VALUE, 0x00
  25           	
  26          		.equ 	IE_MASK,0x10
  27           	
  28          		.equ    pTC_ADDRESS, 0XFF40
  29          		.equ    pTC_TCR, 0
  30          		.equ    pTC_TMR, 2
  31          		.equ    pTC_TC,  4
  32          		.equ    pTC_TIR, 6
  33           		
  34          		.equ    pTC_CMD_STOP,  1
  35          		.equ    pTC_CMD_START, 0
  36           	
  37          		.equ 	PLAYER_MASK, 0X80
  38          		.equ	WALL_MASK,   0X02
  39          		.equ 	NEW_POINT_LED_MASK, 0X1
  40          		.equ	LEVEL_INPUT_MASK, 0xc0
  41          		.equ	BALL_LEDS_MASK, 0xfe
  42          		.equ 	RAKET_MASK, 0x01
  43          		.equ 	LVL_MASK, 0xc0
  44          		.equ	VALUE_OF_1S, 20	;0.05 * 20 = 1s
  45          		.equ	VALUE_OF_5S, 100	;0.05 * 100 = 5s
  46          		.equ	VALUE_OF_25, 5		;0.05 * 5 = 2.5s
  47           	
  48          		.equ	VARIANT_LEVEL, 3
  49           	
  50           	; Seccao:    .startup
  51           	; Descricao: Guarda o código de arranque do sistema
  52           	;
  53           		.section .startup
  54 0000 01 58		b 	_start
  55 0002 5F 0C		ldr	pc, isr_addr
  56           	
  57           	_start:
  58 0004 2D 0C		ldr sp, tos_addr
  59 0006 04 5C		bl SYS_init
  60 0008 1F 0C		ldr	pc, main_addr
  61           	
  62           	tos_addr:
  63 000A FE 02		.word	tos
  64           	main_addr:
  65 000C 32 00		.word	main
  66           	isr_addr:
  67 000E C2 01		.word	isr
  68           		
  69           	;----------------------------------------	
  70           	;# define OUTPORT_INIT_VALUE 0
  71           	;# define LED0_MASK 1
  72           	;
  73           	;uint16_t ticks = 0;
  74           	; 
  75           	;void main() {
  76           	;uint16_t t;
  77           	;	outport_init ( OUTPORT_INIT_VALUE );
  78           	;	timer_init ( SYSCLK_FREQ );
  79           	;   //Habilitar o atendimento das interrupcoes
  80           	;   while(1) {
  81           	;		outport_set_bits(LED0_MASK);
  82           	;		t = sysclk_get_value ();
  83           	;		while ( sysclk_elapsed ( t ) < LED_TOGGLE_TIME );
  84           	;		outport_clear_bits(LED0_MASK);
  85           	;		t = sysclk_get_value ();
  86           	;		while ( sysclk_elapsed ( t ) < LED_TOGGLE_TIME );
  87           	;   }
  88           	;}
  89           	;----------------------------------------	
  90           		.text
  91           	SYS_init:
  92 0010 0E 24		push lr
  93 0012 26 5D		bl outport_init		
  94 0014 F9 5C		bl timer_stop
  95 0016 C0 0C		ldr		r0, ticks_addr
  96 0018 01 00		ldr		r1, [r0, #0]
  97 001A 01 60		mov		r1,  #0
  98 001C 01 20		str		r1, [r0, #0]
  99 001E 00 68		mov r0, PLAYER_MASK	;posição de inicio do jogo
 100 0020 61 0C		ldr r1, ball_pos_addr
 101 0022 10 28		strb r0, [r1]
 102           		
 103 0024 20 63		mov r0, PTC_VALUE
 104 0026 F4 5C		bl timer_init		
 105           	
 106 0028 00 61		mov r0, IE_MASK
 107 002A 40 B0		msr cpsr, r0	
 108 002C 0F 04		pop pc	
 109           		
 110           	ball_pos_addr:
 111 002E B4 02		.word 	ball_pos	
 112           		
 113           	ticks_addr:
 114 0030 B2 02		.word ticks
 115           	
 116           	main:
 117 0032 0E 24		push lr	
 118 0034 E9 5C		bl timer_stop
 119 0036 30 0C		ldr r0, direction_addr
 120 0038 01 60		mov r1, 0
 121 003A 01 28		strb r1, [r0]
 122 003C 01 58		b main_while
 123           		
 124           	direction_addr:
 125 003E B9 02		.word	direction
 126           		
 127           	main_while:
 128 0040 B6 5C		bl reset_all
 129 0042 5A 5C		bl set_ball_leds
 130           		
 131           	wait_for_init_stroke:
 132 0044 10 60		mov r0, RAKET_MASK
 133 0046 EE 5C		bl sw_is_pressed
 134 0048 00 A0		add r0,r0,0
 135 004A 01 44		bzc start_game  
 136 004C FB 5B		b    wait_for_init_stroke
 137           		
 138           	start_game:
 139 004E 86 5C		bl set_level_dif
 140 0050 D2 5C		bl timer_start
 141 0052 79 5C		bl init_timer_lvl
 142 0054 66 5C		bl init_timer_1s
 143 0056 9C 5C		bl mov_ball
 144 0058 4F 5C		bl set_ball_leds
 145           	
 146           	game_loop:
 147 005A 10 60		mov r0, RAKET_MASK
 148 005C E3 5C		bl sw_is_pressed
 149 005E 66 5C		bl get_timer_1s
 150 0060 C5 5C		bl sysclk_elapsed
 151 0062 41 61		mov r1, VALUE_OF_1S
 152 0064 80 B8		cmp r0, r1 ;20
 153 0066 01 48		blo one_second_pass_spik
 154 0068 39 5C		bl one_second_pass
 155           	
 156           	one_second_pass_spik:	
 157 006A 70 0F		ldr r0, new_point_led_addr
 158 006C 00 08		ldrb r0,[r0]
 159 006E 00 A8		sub r0,r0,0
 160 0070 07 40		bzs time_lvl
 161           		
 162 0072 5C 5C		bl get_timer_1s
 163 0074 BB 5C		bl sysclk_elapsed
 164 0076 51 60		mov r1, VALUE_OF_25
 165 0078 80 B8		cmp r0, r1 		;5
 166 007A 02 48		blo	time_lvl	
 167 007C 00 60		mov r0, 0
 168 007E 34 5C		bl set_led_newpoint
 169           		
 170           	time_lvl:
 171 0080 67 5C		bl get_timer_lvl
 172 0082 B4 5C		bl sysclk_elapsed
 173 0084 01 B0		mov r1, r0
 174 0086 67 5C		bl get_level_dif
 175 0088 10 B8		cmp r1, r0
 176 008A 0D 48		blo await_time_or_player
 177           		
 178 008C 5C 5C		bl init_timer_lvl 
 179 008E 44 5C		bl get_ball_position
 180 0090 02 68		mov r2, PLAYER_MASK
 181 0092 00 89		sub r0, r0, r2
 182 0094 01 44		bzc next_move_dir
 183 0096 12 58		b game_over
 184           	
 185           	; averigua direção em que a bola se deve movimentar
 186           	next_move_dir:
 187 0098 3F 5C		bl get_ball_position
 188 009A 00 A9		sub r0, r0, WALL_MASK
 189 009C 01 44		bzc continue_game
 190 009E 32 5C		bl invert_dir
 191           		
 192           	continue_game:
 193 00A0 77 5C		bl mov_ball
 194 00A2 2A 5C		bl set_ball_leds
 195 00A4 50 5C		bl init_timer_lvl
 196           	
 197           	; verifica se o jogador já jogou no caso de a bola se encontrar à frente dele
 198           	await_time_or_player:	
 199           		;verifica se a bola se encontra no jogador
 200 00A6 38 5C		bl get_ball_position
 201 00A8 02 68		mov r2, PLAYER_MASK
 202 00AA 00 89		sub r0, r0, r2	
 203 00AC D6 47		bzc game_loop
 204           		
 205           		;verifica se butão foi premido
 206           		;se o jogador moveu a raquete
 207 00AE 10 60		mov r0, RAKET_MASK
 208 00B0 B9 5C		bl sw_is_pressed
 209 00B2 00 A0		add r0,r0,0
 210 00B4 D2 43		bzs  game_loop
 211           		
 212 00B6 26 5C		bl invert_dir
 213 00B8 F3 5F		bl continue_game
 214 00BA CF 5B		b game_loop
 215           	
 216           	
 217           	;apresenta do score no porto de saída durante 5 segundos
 218           	game_over:
 219 00BC 23 5C		bl invert_dir
 220 00BE F0 6F		mov r0, 0xff
 221 00C0 DC 5C		bl outport_clear_bits
 222 00C2 5C 5C		bl get_score
 223 00C4 D3 5C		bl outport_set_bits
 224 00C6 36 5C		bl init_timer_5s
 225 00C8 44 66		mov r4, VALUE_OF_5S
 226           		
 227           	game_over_loop:
 228 00CA 39 5C		bl get_timer_5s
 229 00CC 8F 5C		bl sysclk_elapsed
 230 00CE 00 BA		cmp r0, r4			;wait 5s
 231 00D0 FC 4B		blo game_over_loop
 232 00D2 9A 5C		bl timer_stop
 233 00D4 F0 6F		mov r0, 0xff
 234 00D6 D1 5C		bl outport_clear_bits
 235 00D8 B3 5B		b  main_while 	
 236           	
 237           	new_point_led_addr:
 238 00DA B8 02		.word 	new_point_led
 239           		
 240           		
 241           	; incrementa score e apresenta indicador de ponto
 242           	one_second_pass:
 243           		;SCORE ++
 244           		;LED ON NEW POINT
 245           		;INIT TIMER
 246 00DC 0E 24		push lr
 247 00DE 21 5C		bl init_timer_1s
 248 00E0 10 60		mov r0, 1
 249 00E2 02 5C		bl set_led_newpoint
 250 00E4 4F 5C		bl add_score
 251 00E6 0F 04		pop pc
 252           		
 253           		
 254           	; set led new point to the valu of r0	
 255           	set_led_newpoint:
 256 00E8 0E 24		push lr
 257 00EA 51 0C		ldr r1, new_point_led_addr_ext
 258 00EC 10 28		strb r0, [r1]
 259 00EE 01 B0		mov r1,r0
 260 00F0 10 60		mov r0, NEW_POINT_LED_MASK
 261 00F2 CB 5C		bl	outport_write_bits
 262 00F4 0F 04		pop pc
 263           		
 264           	new_point_led_addr_ext:
 265 00F6 B8 02			.word	new_point_led
 266           	
 267           	
 268           	;-------------------------------------------------------------------------
 269           	; Funções relacionadas com a bola
 270           	;-------------------------------------------------------------------------
 271           	
 272           	set_ball_leds:
 273 00F8 0E 24		push lr	
 274 00FA 11 0D		ldr	r1, ball_pos_addr_ext1
 275 00FC 11 08		ldrb r1, [r1]
 276 00FE E0 6F		mov r0, BALL_LEDS_MASK
 277 0100 C4 5C		bl	outport_write_bits	
 278 0102 0F 04		pop pc
 279           	
 280           	invert_dir:
 281 0104 0E 24		push lr
 282 0106 C0 0C		ldr r0, direction_addr_ext
 283 0108 01 08		ldrb r1, [r0]
 284 010A 12 60		mov r2, 1
 285 010C 11 D1		eor r1, r1, r2
 286 010E 01 28		strb r1, [r0]
 287 0110 0F 04		pop pc
 288           	
 289           	get_direction:
 290 0112 60 0C		ldr r0, direction_addr_ext
 291 0114 00 08		ldrb r0, [r0]
 292 0116 0F B7		mov pc, lr
 293           	
 294           	get_ball_position:
 295 0118 20 0C		ldr r0, ball_pos_addr_ext1
 296 011A 00 08		ldrb r0, [r0]
 297 011C 0F B7		mov pc, lr
 298           	
 299           	ball_pos_addr_ext1:
 300 011E B4 02		.word 	ball_pos
 301           	
 302           	direction_addr_ext:
 303 0120 B9 02		.word	direction
 304           	
 305           	;-------------------------------------------------------------------------
 306           	; Funções relacionadas com timers
 307           	;-------------------------------------------------------------------------
 308           	
 309           	init_timer_1s:
 310 0122 0E 24		push lr
 311 0124 60 5C		bl sysclk_get_value	
 312 0126 51 0C		ldr r1, timer_1s_addr
 313 0128 10 20		str r0, [r1]	
 314 012A 0F 04		pop pc
 315           	
 316           	get_timer_1s:
 317 012C 20 0C		ldr r0, timer_1s_addr
 318 012E 00 00		ldr r0, [r0]
 319 0130 0F B7		mov pc, lr
 320           		
 321           	timer_1s_addr:
 322 0132 AA 02		.word 	timer_1s
 323           	
 324           	
 325           	init_timer_5s:
 326 0134 0E 24		push lr
 327 0136 57 5C		bl sysclk_get_value	
 328 0138 51 0C		ldr r1, timer_5s_addr
 329 013A 10 20		str r0, [r1]	
 330 013C 0F 04		pop pc
 331           	
 332           	get_timer_5s:
 333 013E 20 0C		ldr r0, timer_5s_addr
 334 0140 00 00		ldr r0, [r0]
 335 0142 0F B7		mov pc, lr
 336           		
 337           	timer_5s_addr:
 338 0144 AC 02		.word 	timer_5s
 339           		
 340           	;-------------------------------------------------------------------------
 341           	; Funções relacionadas com nivel
 342           	;-------------------------------------------------------------------------
 343           	
 344           	init_timer_lvl:
 345 0146 0E 24		push lr
 346 0148 4E 5C		bl sysclk_get_value	
 347 014A 51 0D		ldr r1, timer_level_addr
 348 014C 10 20		str r0, [r1]	
 349 014E 0F 04		pop pc
 350           	
 351           	get_timer_lvl:
 352 0150 20 0D		ldr r0, timer_level_addr
 353 0152 00 00		ldr r0, [r0]
 354 0154 0F B7		mov pc, lr
 355           	
 356           	get_level_dif:
 357 0156 10 0D		ldr r0, current_lvl_addr
 358 0158 00 08		ldrb r0, [r0] 
 359 015A 0F B7		mov pc, lr
 360           		
 361           	set_level_dif:
 362 015C 0E 24		push lr
 363 015E 7C 5C		bl inport_read
 364 0160 01 6C		mov r1, LEVEL_INPUT_MASK
 365 0162 10 C0		and r0, r1, r0
 366 0164 00 EB		lsr r0, r0, #6
 367 0166 31 60		mov r1, VARIANT_LEVEL
 368 0168 80 B8		cmp r0, r1
 369 016A F8 43		beq set_level_dif //TODO
 370           	
 371 016C 51 0C		ldr r1, lvl_list_addr
 372 016E 10 18		ldrb r0, [r1, r0]	//lvl_list + input lvl as offset
 373 0170 41 0C		ldr r1, current_lvl_addr
 374 0172 10 28		strb r0, [r1]
 375 0174 0F 04		pop pc
 376           	
 377           	
 378           	timer_level_addr:
 379 0176 A8 02		.word timer_level
 380           	
 381           	lvl_list_addr:
 382 0178 B5 02		.word lvl_in_time
 383           	
 384           	current_lvl_addr:
 385 017A AE 02		.word current_lvl_dificult_in_time
 386           	
 387           	;-------------------------------------------------------------------------
 388           	; Funções relacionadas com score
 389           	;-------------------------------------------------------------------------
 390           		
 391           	get_score:
 392 017C 0E 24		push lr
 393 017E 01 0E		ldr r1, score_addr
 394 0180 10 00		ldr r0, [r1]
 395 0182 0F 04		pop pc
 396           		
 397           	add_score:	
 398 0184 0E 24		push lr
 399 0186 C0 0D		ldr r0, score_addr
 400 0188 01 00		ldr r1, [r0]
 401 018A 91 A0		add r1, r1, 1
 402 018C 01 20		str r1, [r0]
 403 018E 0F 04		pop pc
 404           	
 405           		
 406           	;-------------------------------------------------------------------------
 407           	; Rotina:    mov_ball
 408           	; Descricao: R
 409           	; Entradas:  -
 410           	; Saidas:    -
 411           	; Efeitos:   Move bola em função de direção
 412           	;			  Na direção do player ou da parede
 413           	; void mov_ball() {
 414           	;   
 415           	;}	
 416           	mov_ball:
 417 0190 0E 24		push lr
 418 0192 BF 5F		bl get_direction
 419 0194 01 B0		mov r1, r0
 420 0196 C0 5F		bl get_ball_position
 421 0198 12 60		mov r2, 1
 422 019A 11 C1		and r1,r1,r2
 423 019C 11 A8		sub r1, r1, 0	
 424 019E 02 40		bzs mov_away
 425           		;move from wall to player (BALL_POS6)01 -> (BALL_POS0)07   
 426 01A0 80 E0		lsl r0, r0,1	
 427 01A2 01 58		b finish_mov
 428           	mov_away:
 429 01A4 80 E8		lsr r0, r0,1
 430           		
 431           	finish_mov:
 432 01A6 21 0C		ldr r1, ball_pos_addr_ext2
 433 01A8 10 28		strb r0, [r1]
 434 01AA 0F 04		pop pc
 435           	
 436           		
 437           	ball_pos_addr_ext2:
 438 01AC B4 02			.word ball_pos
 439           	
 440           	;-------------------------------------------------------------------------
 441           	; Funcao para preparar o inicio de um novo jogo
 442           	; Para o contador, limpa o e limpa o score
 443           	;-------------------------------------------------------------------------
 444           	reset_all:
 445 01AE 0E 24		push	lr
 446 01B0 2B 5C		bl timer_stop
 447           		;timer sysclk  = 0	
 448 01B2 01 0E		ldr		r1, ticks_addr_ext
 449 01B4 00 60		mov r0, 0
 450 01B6 10 20		str		r0, [r1, #0]	
 451           		;score = 0
 452 01B8 31 0C		ldr		r1, score_addr
 453 01BA 00 60		mov r0, 0
 454 01BC 10 20		str		r0, [r1, #0]	
 455           		
 456 01BE 0F 04		pop		pc
 457           	
 458           		
 459           	score_addr:
 460 01C0 B0 02		.word	score
 461           		
 462           	;-------------------------------------------------------------------------
 463           	; Rotina:    isr
 464           	; Descricao: Rotina responsavel pelo processamento do pedido de interrupcao.
 465           	; Entradas:  -
 466           	; Saidas:    -
 467           	; Efeitos:   Incrementa o valor da variavel global ticks
 468           	; void isr() {
 469           	;   ticks++;
 470           	;	//clear Interrupt Request
 471           	;}
 472           	isr:
 473           		; Prologo
 474 01C2 00 24		push	r0
 475 01C4 01 24		push	r1
 476 01C6 02 24		push	r2
 477           		; Corpo da rotina
 478 01C8 50 0D		ldr		r0, ticks_addr_ext
 479 01CA 01 00		ldr		r1, [r0, #0]
 480 01CC 91 A0		add		r1, r1, #1
 481 01CE 01 20		str		r1, [r0, #0]
 482           		; clear Interrupt Request
 483 01D0 F1 6F		mov r1, 0xFF
 484 01D2 70 0E		ldr  r0, ptc_addr
 485 01D4 01 2B		strb r1, [ r0, #pTC_TIR ]
 486           		; Epilogo
 487 01D6 02 04		pop		r2
 488 01D8 01 04		pop		r1
 489 01DA 00 04		pop		r0
 490 01DC 20 B0		movs	pc, lr
 491           		
 492           		
 493           	timer_clearInterrupt:
 494 01DE 00 60		mov r0, 0
 495 01E0 21 0D		ldr r1, timer_addr
 496 01E2 10 2B		strb r0, [ r1, #pTC_TIR ]
 497 01E4 0F B7		mov pc, lr
 498           		
 499           	
 500           	;-------------------------------------------------------------------------
 501           	;Funcao para devolver o valor corrente da variável global ticks.
 502           	;uint16_t sysclk_get_value ( void );
 503           	;	return ticks;
 504           	;-------------------------------------------------------------------------
 505           	sysclk_get_value:
 506 01E6 61 0C		ldr		r1, ticks_addr_ext
 507 01E8 10 00		ldr  	r0, [r1, #0] 	; r0 = ticks
 508 01EA 0F B7		mov		pc, lr
 509           	
 510           	;-------------------------------------------------------------------------
 511           	;Funcao para devolver o tempo decorrido desde o instante last_read. 
 512           	;O tempo e medido em unidades de contagem ( ticks ).
 513           	;uint8_t sysclk_elapsed ( uint16_t last_read ){
 514           	;	return ( ticks - last_read )
 515           	;}
 516           	;-------------------------------------------------------------------------
 517           	sysclk_elapsed:
 518 01EC 31 0C		ldr	 r1, ticks_addr_ext
 519 01EE 12 00		ldr  r2, [r1, #0] 	; r0 = ticks
 520 01F0 20 88		sub  r0, r2, r0
 521 01F2 0F B7		mov  pc,lr
 522           	
 523           	ticks_addr_ext:
 524 01F4 B2 02		.word ticks
 525           		
 526           	;-------------------------------------------------------------------------
 527           	;Funcao para iniciar a contagem no periferico.
 528           	;void timer_start ( void );
 529           	;-------------------------------------------------------------------------
 530           	timer_start:
 531 01F6 01 60		mov  r1, #pTC_CMD_START
 532 01F8 40 0D		ldr  r0, ptc_addr
 533 01FA 01 28		strb r1, [ r0, #pTC_TCR ]
 534 01FC 0F B7		mov  pc, lr
 535           	
 536           	
 537           	timer_write:
 538 01FE 32 0C		ldr 	r2, timer_addr
 539 0200 00 80		add		r0, r0, r0
 540 0202 21 38		strb 	r1, [r2,r0]	
 541 0204 0F B7		mov		pc,lr
 542           	
 543           	timer_addr:
 544 0206 40 FF		.word  pTC_ADDRESS	
 545           	;-------------------------------------------------------------------------
 546           	;Funcao para parar a contagem no periferico. 
 547           	;Colocando o contador com o valor zero.
 548           	;void timer_stop ( void );
 549           	;-------------------------------------------------------------------------
 550           	timer_stop:
 551 0208 11 60		mov  r1, #pTC_CMD_STOP
 552 020A B0 0C		ldr  r0, ptc_addr
 553 020C 01 28		strb r1, [ r0, #pTC_TCR ]
 554 020E 0F B7		mov  pc, lr
 555           	
 556           	;-------------------------------------------------------------------------
 557           	;Funcao que faz a iniciacao do periferico para habilitar o 
 558           	;funcionamento em modo continuo e com intervalo de contagem 
 559           	;interval, em ticks.
 560           	;void timer_init ( uint8_t interval );
 561           	;-------------------------------------------------------------------------
 562           	timer_init:
 563 0210 0E 24		push lr
 564 0212 00 24		push r0				
 565           		; Parar contagem
 566 0214 F9 5F		bl   timer_stop
 567           		; Programar intervalo de contagem
 568 0216 00 04		pop	 r0
 569 0218 41 0C		ldr  r1, ptc_addr
 570 021A 10 29		strb r0, [ r1, #pTC_TMR ]
 571           		; Clear Interrupt Request
 572 021C 21 0C		ldr  r1, ptc_addr
 573 021E 10 2B		strb r0, [ r1, #pTC_TIR ]
 574 0220 0F 04		pop  pc
 575           		
 576           	ptc_addr:
 577 0222 40 FF		.word pTC_ADDRESS
 578           	
 579           	;---------------------------------------------------------------------------------	
 580           	;uint8_t sw_is_pressed(uint8_t pin_mask) {
 581           	;uint8_t sw_new_state;
 582           	;   sw_new_state = inport_test_bits( pin_mask );
 583           	;	if ( sw_state == sw_new_state )
 584           	;		return 0;
 585           	;	sw_state = sw_new_state;
 586           	;   if ( sw_new_state == 0 )
 587           	;		return 0;
 588           	;	return 1;
 589           	;}
 590           	;---------------------------------------------------------------------------------	
 591           	; Rotina:    sw_is_pressed
 592           	; Descricao: 
 593           	; Entradas:  pins_mask
 594           	; Saidas:    devolve 1 se detecta uma transição 0 -> 1 no pino identificado em pin_mask 
 595           	;            e 0 se não detecta.   
 596           	; Efeitos:   
 597           	;---------------------------------------------------------------------------------	
 598           	sw_is_pressed:
 599 0224 0E 24		push	lr
 600 0226 0C 5C		bl		inport_test_bits 
 601           		; r0 = sw_new_state = inport_test_bits(pins_mask)
 602 0228 A1 0C		ldr		r1, sw_state_address
 603 022A 12 08		ldrb	r2, [r1, #0]	; r2 = sw_state
 604 022C 00 B9		cmp		r0, r2			; sw_state == sw_new_state
 605 022E 05 40		beq		sw_is_pressed_0
 606 0230 10 28		strb	r0, [r1, #0]	; sw_state = sw_new_state;
 607 0232 00 A8		sub		r0, r0, #0
 608 0234 02 40		beq		sw_is_pressed_0
 609 0236 10 60		mov		r0, #1
 610 0238 01 58		b		sw_is_pressed_1
 611           	sw_is_pressed_0:
 612 023A 00 60		mov		r0, #0
 613           	sw_is_pressed_1:
 614 023C 0F 04		pop		pc
 615           	
 616           	sw_state_address:
 617 023E BA 02		.word	sw_state
 618           	
 619           	;---------------------------------------------------------------------------------	
 620           	;uint16_t inport_test_bits(uint16_t pins_mask) {
 621           	;	return ((inport_read() & pins_mask) == pins_mask);
 622           	;}
 623           	;---------------------------------------------------------------------------------	
 624           	; Rotina:    inport_test_bits
 625           	; Descricao: Devolve um se todos dos pinos do porto de entrada identificados com o valor um
 626           	; em pins_mask tomaremm o valor logico um , ou zero no caso contrario .
 627           	; Entradas:  Mascara com os bits a testar
 628           	; Saidas:    Devolve um ou zero conforme a descrição.
 629           	; Efeitos:   
 630           	;---------------------------------------------------------------------------------	
 631           	inport_test_bits:
 632 0240 0E 24		push	lr
 633 0242 04 24		push	r4
 634 0244 04 B0		mov		r4, r0
 635 0246 08 5C		bl		inport_read
 636 0248 00 C2		and		r0, r0, r4
 637 024A 00 BA		cmp     r0, r4
 638 024C 02 40		beq		end_inport_test_bit_1
 639 024E 00 60		mov		r0, #0
 640 0250 01 58		b		end_inport_test_bit
 641           	end_inport_test_bit_1:
 642 0252 10 60		mov		r0, #1
 643           	end_inport_test_bit:
 644 0254 04 04		pop		r4
 645 0256 0F 04		pop		pc
 646           		
 647           	;---------------------------------------------------------------------------------	
 648           	;uint16_t inport_read() {
 649           	;	return [INPORT_ADDRESS];
 650           	;}
 651           	;---------------------------------------------------------------------------------	
 652           	; Rotina:    inport_read
 653           	; Descricao: Devolve o valor corrente do estado dos pinos do porto de entrada.
 654           	; Entradas:  
 655           	; Saidas:    Valor corrente do porto
 656           	; Efeitos:   
 657           	;---------------------------------------------------------------------------------	
 658           	inport_read:
 659 0258 20 0C		ldr		r0, inport_address_local
 660 025A 00 08		ldrb	r0, [r0, #0]
 661 025C 0F B7		mov		pc, lr
 662           	
 663           	inport_address_local:
 664 025E 00 FF		.word	INPORT_ADDRESS
 665           	;---------------------------------------------------------------------------------	
 666           	;uint8_t outport_init(uint8_t initial_value) {
 667           	;	outport_img = initial_value;
 668           	;	outport_write(outport_img);
 669           	;}
 670           	;---------------------------------------------------------------------------------	
 671           	; Rotina:    outport_init
 672           	; Descricao: Inicia o porto de saida, atribuindo-lhe o valor do argumento passado 
 673           	;			 a rotina.
 674           	; Entradas:  Valor para iniciar o porto de saida
 675           	; Saidas:    
 676           	; Efeitos:   Atualiza o valor da variavel imagem do porto
 677           	;---------------------------------------------------------------------------------	
 678           	outport_init:
 679 0260 0E 24		push	lr
 680 0262 00 60		mov r0 , #0
 681 0264 F1 0D		ldr		r1, outport_img_address
 682 0266 10 28		strb	r0, [r1, #0]
 683 0268 1A 5C		bl		outport_write
 684 026A 0F 04		pop		pc
 685           	
 686           	;---------------------------------------------------------------------------------	
 687           	;void outport_set_bits(uint8_t pins_mask) {
 688           	;	outport_img |= pins_mask;
 689           	;	ourport_write(outport_img);
 690           	;}
 691           	;---------------------------------------------------------------------------------	
 692           	; Rotina:    outport_set_bits
 693           	; Descricao: Atribui o valor logico '1' aos pinos do porto de saida identificados 
 694           	;			 com o valor 1 no argumento passado a rotina. O estado dos restantes 
 695           	;			 bits nao e alterado.
 696           	; Entradas:  Mascara com os bits a alterar
 697           	; Saidas:    
 698           	; Efeitos:   Atualiza o valor da variavel imagem do porto
 699           	;---------------------------------------------------------------------------------	
 700           	outport_set_bits:
 701 026C 0E 24		push	lr
 702 026E A1 0D		ldr		r1, outport_img_address
 703 0270 12 08		ldrb	r2, [r1, #0]
 704 0272 20 C8		orr		r0, r2, r0
 705 0274 10 28		strb	r0, [r1, #0]
 706 0276 13 5C		bl		outport_write
 707 0278 0F 04		pop		pc
 708           	
 709           	;---------------------------------------------------------------------------------	
 710           	;void outport_clear_bits(uint8_t pins_mask) {
 711           	;	outport_img &= ~pins_mask ;
 712           	;	ourport_write(outport_img);
 713           	;}
 714           	;---------------------------------------------------------------------------------	
 715           	; Rotina:    outport_clear_bits
 716           	; Descricao: Atribui o valor logico '0' aos pinos do porto de saida identificados 
 717           	;			 com o valor 1 no argumento passado a rotina. O estado dos restantes 
 718           	;			 bits nao e alterado.
 719           	; Entradas:  Mascara com os bits a alterar
 720           	; Saidas:    
 721           	; Efeitos:   Atualiza o valor da variavel imagem do porto
 722           	;---------------------------------------------------------------------------------	
 723           	outport_clear_bits:
 724 027A 0E 24		push	lr
 725 027C 31 0D		ldr		r1, outport_img_address
 726 027E 12 08		ldrb	r2, [r1, #0]
 727 0280 10 B0		mvn		r0, r0
 728 0282 20 C0		and		r0, r2, r0
 729 0284 10 28		strb	r0, [r1, #0]
 730 0286 0B 5C		bl		outport_write
 731 0288 0F 04		pop		pc
 732           	
 733           	;---------------------------------------------------------------------------------	
 734           	;void outport_write_bits(uint8_t pins_mask, uint8_t value) {
 735           	;	value &= pins_mask;
 736           	;	outport_img &= ~pins_mask;
 737           	;	outport_img |= value;
 738           	;	ourport_write(outport_img)
 739           	;}
 740           	;---------------------------------------------------------------------------------	
 741           	; Rotina:    outport_write_bits
 742           	; Descricao: Atribui aos pinos do porto de saida identificados com o valor lógico
 743           	;            um em pins_mask o valor dos bits correspondentes de value. O estado 
 744           	;            dos restantes bits nao e alterado.
 745           	; Entradas:  Mascara com os bits a alterar
 746           	;         :  valor dos bits a alterar  
 747           	; Saidas:    
 748           	; Efeitos:   Atualiza o valor da variavel imagem do porto
 749           	;---------------------------------------------------------------------------------	
 750           	outport_write_bits:
 751 028A 0E 24		push	lr
 752 028C 81 C0		and		r1, r0, r1				; r1 = pins_mask & value
 753 028E A2 0C		ldr		r2, outport_img_address
 754 0290 23 08		ldrb	r3, [r2, #0]
 755 0292 10 B0		mvn		r0, r0					; ~pins_mask
 756 0294 33 C0		and		r3, r3, r0				; outport_img &= ~pins_mask;
 757 0296 B0 C8		orr		r0, r3, r1				; outport_img |= pins_mask & value;
 758 0298 20 28		strb	r0, [r2, #0]
 759 029A 01 5C		bl		outport_write
 760 029C 0F 04		pop		pc
 761           	
 762           	;---------------------------------------------------------------------------------	
 763           	;void outport_write(uint8_t value) {
 764           	;	outport_img = value;
 765           	;	[OUTPORT_ADDRESS] = outport_img;
 766           	;}
 767           	;---------------------------------------------------------------------------------	
 768           	; Rotina:    outport_write
 769           	; Descricao: Atribui aos pinos do porto de saida o valor dos bits correspondentes de value.
 770           	; Entradas:  Valor a escrever no porto
 771           	; Saidas:    
 772           	; Efeitos:   Atualiza o valor da variavel imagem do porto
 773           	;---------------------------------------------------------------------------------	
 774           	outport_write:
 775 029E 31 0C		ldr		r1, outport_addr
 776 02A0 10 28		strb	r0, [r1, #0]
 777 02A2 0F B7		mov		pc, lr
 778           	
 779           	outport_img_address:
 780 02A4 BC 02		.word	outport_img
 781           	
 782           	outport_addr:
 783 02A6 00 FF		.word	OUTPORT_ADDRESS
 784           		
 785           	; Seccao:    .data
 786           	; Descricao: Guarda as variáveis globais com valor inicial definido
 787           	;
 788           		.data
 789           	timer_level:
 790 02A8 00 00		.word	0
 791           		
 792           	timer_1s:
 793 02AA 00 00		.word	0
 794           		
 795           	timer_5s:
 796 02AC 00 00		.word	0
 797           		
 798           	current_lvl_dificult_in_time:
 799 02AE 0A 00		.word	10
 800           	
 801           	score:
 802 02B0 00 00		.word	0
 803           		
 804           	ticks:
 805 02B2 00 00		.word	0		; uint16_t ticks;
 806           		
 807           	ball_pos:
 808 02B4 80		.byte	0x80
 809           	lvl_in_time:
 810           		.byte	20, 10, 5		; 1s / 0.5s / 0.25s
 810 02B5 14 0A 05
 811           	
 812           	new_point_led:
 813 02B8 00		.byte	0x00
 814           		
 815           	direction: ; 0 away from player 1 into the player
 816 02B9 00		.byte	0x00
 817           	sw_state:
 818 02BA 00		.byte 	0
 819           	; Seccao:    .bss
 820           	; Descricao: Guarda as variáveis globais sem valor inicial definido
 821           	;
 822           		.section .bss
 823           	outport_img:			; Imagem do porto de saida no programa
 824 02BC 00   		.space	1	
 825           	
 826           	; Seccao:    .stack
 827           	; Descricao: Implementa a pilha com o tamanho definido pelo simbolo STACK_SIZE
 828           	;
 829           		.section .stack
 830 02BE 00   		.space STACK_SIZE
 830 .... ..
 830 02FD 00
 831           	tos:
