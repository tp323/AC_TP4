P16 assembler v1.3.2 (May  7 2020)	tp4.lst	Sat Jun 18 17:39:00 2022

Sections
Index   Name            Addresses       Size
0       .startup        0000 - 000F     0010 16
1       .text           0010 - 02B5     02A6 678
2       .data           02B6 - 02C8     0013 19
3       .bss            02CA - 02CA     0001 1
4       .stack          02CC - 030B     0040 64

Symbols
Name                    Type      Value      Section
_start                  LABEL     0004 4     .startup
add_score               LABEL     018A 394   .text
BALL_LEDS_MASK          ABSOLUTE  00FE 254   .startup
ball_pos                LABEL     02C2 706   .data
ball_pos_addr           LABEL     0180 384   .text
ball_pos_addr_cc        LABEL     01B6 438   .text
ball_pos_addr_ddd       LABEL     002E 46    .text
ball_pos_addrb          LABEL     0122 290   .text
continue_game           LABEL     0098 152   .text
CPSR_BIT_I              ABSOLUTE  0010 16    .startup
current_lvl_addr        LABEL     017E 382   .text
current_lvl_dificult_in_time LABEL     02BC 700   .data
direction               LABEL     02C7 711   .data
direction_addr          LABEL     0124 292   .text
direction_addr_bb       LABEL     01B4 436   .text
direction_addr_cc       LABEL     003E 62    .text
end_inport_test_bit     LABEL     0262 610   .text
end_inport_test_bit_1   LABEL     0260 608   .text
finish_mov              LABEL     01AE 430   .text
game_loop               LABEL     005A 90    .text
game_over               LABEL     00BE 190   .text
game_over_loop          LABEL     00CA 202   .text
get_ball_position       LABEL     011C 284   .text
get_direction           LABEL     0116 278   .text
get_level_dif           LABEL     015A 346   .text
get_score               LABEL     0182 386   .text
get_timer_1s            LABEL     0130 304   .text
get_timer_5s            LABEL     0142 322   .text
get_timer_lvl           LABEL     0154 340   .text
IE_MASK                 ABSOLUTE  0010 16    .startup
init_timer_1s           LABEL     0126 294   .text
init_timer_5s           LABEL     0138 312   .text
init_timer_lvl          LABEL     014A 330   .text
INPORT_ADDRESS          ABSOLUTE  FF00 65280 .startup
inport_address_local    LABEL     026C 620   .text
inport_read             LABEL     0266 614   .text
inport_test_bits        LABEL     024E 590   .text
invert_dir              LABEL     0108 264   .text
isr                     LABEL     01B8 440   .text
isr_addr                LABEL     000E 14    .startup
LED0_MASK               ABSOLUTE  0001 1     .startup
LEVEL_INPUT_MASK        ABSOLUTE  00C0 192   .startup
level_up_skip           LABEL     00A4 164   .text
lvl_in_time             LABEL     02C3 707   .data
lvl_list_addr           LABEL     017C 380   .text
LVL_MASK                ABSOLUTE  00C0 192   .startup
main                    LABEL     0032 50    .text
main_addr               LABEL     000C 12    .startup
main_while              LABEL     0040 64    .text
mov_away                LABEL     01AC 428   .text
mov_ball                LABEL     0198 408   .text
new_point_led           LABEL     02C6 710   .data
new_point_led_addr      LABEL     00D8 216   .text
new_point_led_addrbbb   LABEL     00FA 250   .text
NEW_POINT_LED_MASK      ABSOLUTE  0001 1     .startup
one_second_pass         LABEL     00DC 220   .text
one_second_pass_spik    LABEL     006A 106   .text
outport_addr            LABEL     02B4 692   .text
OUTPORT_ADDRESS         ABSOLUTE  FF00 65280 .startup
outport_clear_bits      LABEL     0288 648   .text
outport_img             LABEL     02CA 714   .bss
outport_img_address     LABEL     02B2 690   .text
outport_init            LABEL     026E 622   .text
OUTPORT_INIT_VALUE      ABSOLUTE  0000 0     .startup
outport_set_bits        LABEL     027A 634   .text
outport_write           LABEL     02AC 684   .text
outport_write_bits      LABEL     0298 664   .text
PLAYER_MASK             ABSOLUTE  0080 128   .startup
ptc_addr                LABEL     021A 538   .text
pTC_ADDRESS             ABSOLUTE  FF40 65344 .startup
pTC_CMD_START           ABSOLUTE  0000 0     .startup
pTC_CMD_STOP            ABSOLUTE  0001 1     .startup
pTC_TC                  ABSOLUTE  0004 4     .startup
pTC_TCR                 ABSOLUTE  0000 0     .startup
pTC_TIR                 ABSOLUTE  0006 6     .startup
pTC_TMR                 ABSOLUTE  0002 2     .startup
PTC_VALUE               ABSOLUTE  0032 50    .startup
RAKET_MASK              ABSOLUTE  0001 1     .startup
reset_all               LABEL     0238 568   .text
score                   LABEL     02BE 702   .data
score_addr              LABEL     00DA 218   .text
score_addr_bb           LABEL     0196 406   .text
score_addr_reset        LABEL     024C 588   .text
set_ball_leds           LABEL     00FC 252   .text
set_led_newpoint        LABEL     00EC 236   .text
set_level_dif           LABEL     0160 352   .text
STACK_SIZE              ABSOLUTE  0040 64    .startup
start_game              LABEL     004E 78    .text
sw_is_pressed           LABEL     021C 540   .text
sw_is_pressed_0         LABEL     0232 562   .text
sw_is_pressed_1         LABEL     0234 564   .text
sw_state                LABEL     02C8 712   .data
sw_state_address        LABEL     0236 566   .text
SYS_init                LABEL     0010 16    .text
sysclk_elapsed          LABEL     01E4 484   .text
sysclk_get_value        LABEL     01DE 478   .text
ticks                   LABEL     02C0 704   .data
ticks_addr              LABEL     01EC 492   .text
ticks_addr_reset        LABEL     024A 586   .text
ticks_addrb             LABEL     0030 48    .text
time_lvl                LABEL     0080 128   .text
timer_1s                LABEL     02B8 696   .data
timer_1s_adrr           LABEL     00EA 234   .text
timer_1s_adrrb          LABEL     0136 310   .text
timer_1s_adrrvv         LABEL     00D6 214   .text
timer_5s                LABEL     02BA 698   .data
timer_5s_adrrb          LABEL     0148 328   .text
timer_addressr          LABEL     01DC 476   .text
timer_addressrc         LABEL     01FE 510   .text
timer_clearInterrupt    LABEL     01D4 468   .text
timer_init              LABEL     0208 520   .text
timer_level             LABEL     02B6 694   .data
timer_level_adrr        LABEL     00E8 232   .text
timer_level_adrrb       LABEL     017A 378   .text
timer_start             LABEL     01EE 494   .text
timer_stop              LABEL     0200 512   .text
timer_write             LABEL     01F6 502   .text
tos                     LABEL     030C 780   .stack
tos_addr                LABEL     000A 10    .startup
VALUE_OF_1S             ABSOLUTE  0014 20    .startup
VALUE_OF_25             ABSOLUTE  0005 5     .startup
VALUE_OF_5S             ABSOLUTE  0064 100   .startup
VARIANT_LEVEL           ABSOLUTE  0003 3     .startup
wait_for_init_stroke    LABEL     0044 68    .text
WALL_MASK               ABSOLUTE  0002 2     .startup

Code listing
   1           	
   2           	; Autor:     Manuel Fonseca   n: 48052
   3           	; Autor:	 Manuel Henriques n: 47202
   4           	; Autor:	 Tiago Pardal 	  n: 47206
   5           	
   6           	
   7           	
   8           	
   9           	; Definicao dos valores dos simbolos utilizados no programa
  10           	; valores calculados para o pico timer ligado a 1khz
  11           	
  12          		.equ	STACK_SIZE, 64           ; Dimensao do stack (em bytes)
  13           	
  14          		.equ    INPORT_ADDRESS, 0xFF00  ; Endereço do porto de entrada da placa SDP16
  15          		.equ	OUTPORT_ADDRESS, 0xFF00 ; Endereço do porto de saida da placa SDP16
  16           	
  17          		.equ	CPSR_BIT_I, 0x10          ; Mascara para a flag I do registo CPSR
  18          		.equ	PTC_VALUE, 50			; Intervalo de contagem do circuito pTC ; valores calculados para o pico timer ligado a 1khz
  19           		
  20           	                                        ; que suporta a implementação do sysclk
  21           											; fin_pTC = 1kHz fout_ptc=20Hz => T=50ms 
  22           											
  23          		.equ 	LED0_MASK, 0x01
  24          		.equ 	OUTPORT_INIT_VALUE, 0x00
  25           	
  26          		.equ 	IE_MASK,0x10
  27           	
  28          		.equ    pTC_ADDRESS, 0XFF40
  29          		.equ    pTC_TCR, 0
  30          		.equ    pTC_TMR, 2
  31          		.equ    pTC_TC,  4
  32          		.equ    pTC_TIR, 6
  33           		
  34          		.equ    pTC_CMD_STOP,  1
  35          		.equ    pTC_CMD_START, 0
  36           	
  37          		.equ 	PLAYER_MASK, 0X80
  38          		.equ	WALL_MASK,   0X02
  39          		.equ 	NEW_POINT_LED_MASK, 0X1
  40          		.equ	LEVEL_INPUT_MASK, 0xc0
  41          		.equ	BALL_LEDS_MASK, 0xfe
  42          		.equ 	RAKET_MASK, 0x01
  43          		.equ 	LVL_MASK, 0xc0
  44          		.equ	VALUE_OF_1S, 20	;0.05 * 20 = 1s
  45          		.equ	VALUE_OF_5S, 100	;0.05 * 100 = 5s
  46          		.equ	VALUE_OF_25, 5		;0.05 * 5 = 2.5s
  47           	
  48          		.equ	VARIANT_LEVEL, 3
  49           	
  50           	; Seccao:    .startup
  51           	; Descricao: Guarda o código de arranque do sistema
  52           	;
  53           		.section .startup
  54 0000 01 58		b 	_start
  55 0002 5F 0C		ldr	pc, isr_addr
  56           	
  57           	_start:
  58 0004 2D 0C		ldr sp, tos_addr
  59 0006 04 5C		bl SYS_init
  60 0008 1F 0C		ldr	pc, main_addr
  61           	
  62           	tos_addr:
  63 000A 0C 03		.word	tos
  64           	main_addr:
  65 000C 32 00		.word	main
  66           	isr_addr:
  67 000E B8 01		.word	isr
  68           		
  69           	;----------------------------------------	
  70           	;# define OUTPORT_INIT_VALUE 0
  71           	;# define LED0_MASK 1
  72           	;
  73           	;uint16_t ticks = 0;
  74           	; 
  75           	;void main() {
  76           	;uint16_t t;
  77           	;	outport_init ( OUTPORT_INIT_VALUE );
  78           	;	timer_init ( SYSCLK_FREQ );
  79           	;   //Habilitar o atendimento das interrupcoes
  80           	;   while(1) {
  81           	;		outport_set_bits(LED0_MASK);
  82           	;		t = sysclk_get_value ();
  83           	;		while ( sysclk_elapsed ( t ) < LED_TOGGLE_TIME );
  84           	;		outport_clear_bits(LED0_MASK);
  85           	;		t = sysclk_get_value ();
  86           	;		while ( sysclk_elapsed ( t ) < LED_TOGGLE_TIME );
  87           	;   }
  88           	;}
  89           	;----------------------------------------	
  90           		.text
  91           	SYS_init:
  92 0010 0E 24		push lr
  93 0012 2D 5D		bl outport_init		
  94 0014 F5 5C		bl timer_stop
  95 0016 C0 0C		ldr		r0, ticks_addrb
  96 0018 01 00		ldr		r1, [r0, #0]
  97 001A 01 60		mov		r1,  #0
  98 001C 01 20		str		r1, [r0, #0]
  99 001E 00 68		mov r0, PLAYER_MASK	;posição de inicio do jogo
 100 0020 61 0C		ldr r1, ball_pos_addr_ddd
 101 0022 10 28		strb r0, [r1]
 102           		
 103 0024 20 63		mov r0, PTC_VALUE
 104 0026 F0 5C		bl timer_init		
 105           	
 106 0028 00 61		mov r0, IE_MASK
 107 002A 40 B0		msr cpsr, r0	
 108 002C 0F 04		pop pc	
 109           		
 110           	ball_pos_addr_ddd:
 111 002E C2 02		.word 	ball_pos	
 112           		
 113           	ticks_addrb:
 114 0030 C0 02		.word ticks
 115           	
 116           	main:
 117 0032 0E 24		push lr	
 118 0034 E5 5C		bl timer_stop
 119 0036 30 0C		ldr r0, direction_addr_cc
 120 0038 01 60		mov r1, 0
 121 003A 01 28		strb r1, [r0]
 122 003C 01 58		b main_while
 123           		
 124           	direction_addr_cc:
 125 003E C7 02		.word	direction
 126           		
 127           	main_while:
 128 0040 5D 5C		bl set_ball_leds
 129 0042 FA 5C		bl reset_all
 130           		
 131           	wait_for_init_stroke:
 132 0044 10 60		mov r0, RAKET_MASK
 133 0046 EA 5C		bl sw_is_pressed
 134 0048 00 A0		add r0,r0,0
 135 004A 01 44		bzc start_game  
 136 004C FB 5B		b    wait_for_init_stroke
 137           		
 138           	start_game:
 139 004E 88 5C		bl set_level_dif
 140 0050 CE 5C		bl timer_start
 141 0052 7B 5C		bl init_timer_lvl
 142 0054 68 5C		bl init_timer_1s
 143 0056 A0 5C		bl mov_ball
 144 0058 51 5C		bl set_ball_leds
 145           	
 146           	game_loop:
 147 005A 10 60		mov r0, RAKET_MASK
 148 005C DF 5C		bl sw_is_pressed
 149 005E 68 5C		bl get_timer_1s
 150 0060 C1 5C		bl sysclk_elapsed
 151 0062 41 61		mov r1, VALUE_OF_1S
 152 0064 80 B8		cmp r0, r1 ;20
 153 0066 01 48		blo one_second_pass_spik
 154 0068 39 5C		bl one_second_pass
 155           	
 156           	one_second_pass_spik:	
 157 006A 60 0F		ldr r0, new_point_led_addr
 158 006C 00 08		ldrb r0,[r0]
 159 006E 00 A8		sub r0,r0,0
 160 0070 07 40		bzs time_lvl
 161           		
 162 0072 5E 5C		bl get_timer_1s
 163 0074 B7 5C		bl sysclk_elapsed
 164 0076 51 60		mov r1, VALUE_OF_25
 165 0078 80 B8		cmp r0, r1 ;20
 166 007A 02 48		blo	time_lvl	
 167 007C 00 60		mov r0, 0
 168 007E 36 5C		bl set_led_newpoint
 169           		
 170           	time_lvl:
 171 0080 69 5C		bl get_timer_lvl
 172 0082 B0 5C		bl sysclk_elapsed
 173 0084 01 B0		mov r1, r0
 174 0086 69 5C		bl get_level_dif
 175 0088 10 B8		cmp r1, r0
 176 008A 0C 48		blo level_up_skip
 177           		
 178 008C 5E 5C		bl init_timer_lvl 
 179 008E 46 5C		bl get_ball_position
 180 0090 02 68		mov r2, PLAYER_MASK
 181 0092 00 89		sub r0, r0, r2
 182 0094 01 44		bzc continue_game
 183 0096 13 58		b game_over
 184           		
 185           	continue_game:
 186 0098 41 5C		bl get_ball_position
 187 009A 00 A9		sub r0, r0, WALL_MASK
 188 009C 35 40		beq invert_dir
 189 009E 7C 5C		bl mov_ball
 190 00A0 2D 5C		bl set_ball_leds
 191 00A2 53 5C		bl init_timer_lvl
 192           		
 193           	level_up_skip:	
 194           		;ball in wall ?
 195           		;ball in player? 
 196 00A4 3B 5C		bl get_ball_position
 197 00A6 02 68		mov r2, PLAYER_MASK
 198 00A8 00 89		sub r0, r0, r2	
 199 00AA D7 47		bzc game_loop
 200           		;raket? 
 201 00AC 10 60		mov r0, RAKET_MASK
 202 00AE B6 5C		bl sw_is_pressed
 203 00B0 00 A0		add r0,r0,0
 204 00B2 D3 43		bzs  game_loop
 205           		
 206 00B4 29 5C		bl invert_dir
 207 00B6 49 5C		bl init_timer_lvl	
 208 00B8 6F 5C		bl mov_ball
 209 00BA 20 5C		bl set_ball_leds
 210           		
 211 00BC CE 5B		b game_loop
 212           	
 213           	
 214           	;apresenta do score no porto de saída durante 5 segundos
 215           	game_over:
 216 00BE 24 5C		bl invert_dir
 217 00C0 E3 5C		bl outport_clear_bits
 218 00C2 5F 5C		bl get_score
 219 00C4 DA 5C		bl outport_set_bits
 220 00C6 38 5C		bl init_timer_5s
 221 00C8 44 66		mov r4, VALUE_OF_5S
 222           		
 223           	game_over_loop:
 224 00CA 3B 5C		bl get_timer_5s
 225 00CC 8B 5C		bl sysclk_elapsed
 226 00CE 00 BA		cmp r0, r4			;wait 5s
 227 00D0 FC 4B		blo game_over_loop
 228 00D2 96 5C		bl timer_stop
 229 00D4 B5 5B		b  main_while 	
 230           		
 231           	timer_1s_adrrvv:
 232 00D6 B8 02		.word 	timer_1s
 233           	
 234           	new_point_led_addr:
 235 00D8 C6 02		.word 	new_point_led
 236           		
 237           	score_addr:
 238 00DA BE 02		.word 	score
 239           		
 240           	one_second_pass:
 241           		;SCORE ++
 242           		;LED ON NEW POINT
 243           		;INIT TIMER
 244 00DC 0E 24		push lr
 245 00DE 23 5C		bl init_timer_1s
 246 00E0 10 60		mov r0, 1
 247 00E2 04 5C		bl set_led_newpoint
 248 00E4 52 5C		bl add_score
 249 00E6 0F 04		pop pc
 250           		
 251           		
 252           	timer_level_adrr:
 253 00E8 B6 02		.word timer_level
 254           	
 255           	timer_1s_adrr:
 256 00EA B8 02		.word 	timer_1s	
 257           		
 258           		
 259           	; set led new point to the valu of r0	
 260           	set_led_newpoint:
 261 00EC 0E 24		push lr
 262 00EE 51 0C		ldr r1, new_point_led_addrbbb
 263 00F0 10 28		strb r0, [r1]
 264 00F2 01 B0		mov r1,r0
 265 00F4 10 60		mov r0, NEW_POINT_LED_MASK
 266 00F6 D0 5C		bl	outport_write_bits
 267 00F8 0F 04		pop pc
 268           		
 269           	new_point_led_addrbbb:
 270 00FA C6 02			.word	new_point_led
 271           	
 272           	
 273           	/*
 274           		---------------------------------------	Ball Releated Functions ---------------------------------------
 275           	*/
 276           	
 277           	set_ball_leds:
 278 00FC 0E 24		push lr	
 279 00FE 11 0D		ldr	r1, ball_pos_addrb
 280 0100 11 08		ldrb r1, [r1]
 281 0102 E0 6F		mov r0, BALL_LEDS_MASK
 282 0104 C9 5C		bl	outport_write_bits	
 283 0106 0F 04		pop pc
 284           	
 285           	invert_dir:
 286 0108 0E 24		push lr
 287 010A C0 0C		ldr r0, direction_addr
 288 010C 01 08		ldrb r1, [r0]
 289 010E 12 60		mov r2, 1
 290 0110 11 D1		eor r1, r1, r2
 291 0112 01 28		strb r1, [r0]
 292 0114 0F 04		pop pc
 293           	
 294           	get_direction:
 295 0116 60 0C		ldr r0, direction_addr
 296 0118 00 08		ldrb r0, [r0]
 297 011A 0F B7		mov pc, lr
 298           	
 299           	get_ball_position:
 300 011C 20 0C		ldr r0, ball_pos_addrb
 301 011E 00 08		ldrb r0, [r0]
 302 0120 0F B7		mov pc, lr
 303           	
 304           	ball_pos_addrb:
 305 0122 C2 02		.word 	ball_pos
 306           	
 307           	direction_addr:
 308 0124 C7 02		.word	direction
 309           	
 310           	/*
 311           		---------------------------------------	1s Timer Releated Functions ---------------------------------------
 312           	*/
 313           	
 314           	init_timer_1s:
 315 0126 0E 24		push lr
 316 0128 5A 5C		bl sysclk_get_value	
 317 012A 51 0C		ldr r1, timer_1s_adrrb
 318 012C 10 20		str r0, [r1]	
 319 012E 0F 04		pop pc
 320           	
 321           	get_timer_1s:
 322 0130 20 0C		ldr r0, timer_1s_adrrb
 323 0132 00 00		ldr r0, [r0]
 324 0134 0F B7		mov pc, lr
 325           		
 326           	timer_1s_adrrb:
 327 0136 B8 02		.word 	timer_1s
 328           	
 329           	/*
 330           		---------------------------------------	5s Timer Releated Functions ---------------------------------------
 331           	*/
 332           	
 333           	init_timer_5s:
 334 0138 0E 24		push lr
 335 013A 51 5C		bl sysclk_get_value	
 336 013C 51 0C		ldr r1, timer_5s_adrrb
 337 013E 10 20		str r0, [r1]	
 338 0140 0F 04		pop pc
 339           	
 340           	get_timer_5s:
 341 0142 20 0C		ldr r0, timer_5s_adrrb
 342 0144 00 00		ldr r0, [r0]
 343 0146 0F B7		mov pc, lr
 344           		
 345           	timer_5s_adrrb:
 346 0148 BA 02		.word 	timer_5s
 347           	/*
 348           		---------------------------------------	Level Releated Functions ---------------------------------------
 349           	*/
 350           	
 351           	init_timer_lvl:
 352 014A 0E 24		push lr
 353 014C 48 5C		bl sysclk_get_value	
 354 014E 51 0D		ldr r1, timer_level_adrrb
 355 0150 10 20		str r0, [r1]	
 356 0152 0F 04		pop pc
 357           	
 358           	get_timer_lvl:
 359 0154 20 0D		ldr r0, timer_level_adrrb
 360 0156 00 00		ldr r0, [r0]
 361 0158 0F B7		mov pc, lr
 362           	
 363           	get_level_dif:
 364 015A 10 0D		ldr r0, current_lvl_addr
 365 015C 00 08		ldrb r0, [r0] 
 366 015E 0F B7		mov pc, lr
 367           		
 368           	set_level_dif:
 369 0160 0E 24		push lr
 370 0162 81 5C		bl inport_read
 371 0164 01 6C		mov r1, LEVEL_INPUT_MASK
 372 0166 10 C0		and r0, r1, r0
 373 0168 00 EB		lsr r0, r0, #6
 374 016A 31 60		mov r1, VARIANT_LEVEL
 375 016C 80 B8		cmp r0, r1
 376 016E F8 43		beq set_level_dif //TODO
 377           	
 378 0170 51 0C		ldr r1, lvl_list_addr
 379 0172 10 18		ldrb r0, [r1, r0]	//lvl_list + input lvl as offset
 380 0174 41 0C		ldr r1, current_lvl_addr
 381 0176 10 28		strb r0, [r1]
 382 0178 0F 04		pop pc
 383           	
 384           	
 385           	timer_level_adrrb:
 386 017A B6 02		.word timer_level
 387           	
 388           	lvl_list_addr:
 389 017C C3 02		.word lvl_in_time
 390           	
 391           	current_lvl_addr:
 392 017E BC 02		.word current_lvl_dificult_in_time
 393           	
 394           	/*
 395           		-------------------------------------------------------------------------------------------------------
 396           	*/
 397           	
 398           	ball_pos_addr:
 399 0180 C2 02		.word 	ball_pos
 400           		
 401           	get_score:
 402 0182 0E 24		push lr
 403 0184 81 0C		ldr r1, score_addr_bb
 404 0186 10 00		ldr r0, [r1]
 405 0188 0F 04		pop pc
 406           		
 407           	add_score:	
 408 018A 0E 24		push lr
 409 018C 40 0C		ldr r0, score_addr_bb
 410 018E 01 00		ldr r1, [r0]
 411 0190 91 A0		add r1, r1, 1
 412 0192 01 20		str r1, [r0]
 413 0194 0F 04		pop pc
 414           		
 415           		
 416           	score_addr_bb:
 417 0196 BE 02		.word score
 418           	;-------------------------------------------------------------------------
 419           	; Rotina:    mov_ball
 420           	; Descricao: R
 421           	; Entradas:  -
 422           	; Saidas:    -
 423           	; Efeitos:   Move bola em função de direção
 424           	;			  Na direção do player ou da parede
 425           	; void mov_ball() {
 426           	;   
 427           	;}	
 428           	mov_ball:
 429 0198 0E 24		push lr
 430 019A BD 5F		bl get_direction
 431 019C 01 B0		mov r1, r0
 432 019E BE 5F		bl get_ball_position
 433 01A0 12 60		mov r2, 1
 434 01A2 11 C1		and r1,r1,r2
 435 01A4 11 A8		sub r1, r1, 0	
 436 01A6 02 40		bzs mov_away
 437           		;move from wall to player (BALL_POS6)01 -> (BALL_POS0)07   
 438 01A8 80 E0		lsl r0, r0,1	
 439 01AA 01 58		b finish_mov
 440           	mov_away:
 441 01AC 80 E8		lsr r0, r0,1
 442           		
 443           	finish_mov:
 444 01AE 31 0C		ldr r1, ball_pos_addr_cc
 445 01B0 10 28		strb r0, [r1]
 446 01B2 0F 04		pop pc
 447           		
 448           		
 449           	direction_addr_bb:
 450 01B4 C7 02		.word direction
 451           		
 452           	ball_pos_addr_cc:
 453 01B6 C2 02			.word ball_pos
 454           	
 455           	;-------------------------------------------------------------------------
 456           	; Rotina:    isr
 457           	; Descricao: Rotina responsavel pelo processamento do pedido de interrupcao.
 458           	; Entradas:  -
 459           	; Saidas:    -
 460           	; Efeitos:   Incrementa o valor da variavel global ticks
 461           	; void isr() {
 462           	;   ticks++;
 463           	;	//clear Interrupt Request
 464           	;}
 465           	isr:
 466           		; Prologo
 467 01B8 00 24		push	r0
 468 01BA 01 24		push	r1
 469 01BC 02 24		push	r2
 470           		; Corpo da rotina
 471 01BE 60 0D		ldr		r0, ticks_addr
 472 01C0 01 00		ldr		r1, [r0, #0]
 473 01C2 91 A0		add		r1, r1, #1
 474 01C4 01 20		str		r1, [r0, #0]
 475           		; clear Interrupt Request
 476 01C6 F1 6F		mov r1, 0xFF
 477 01C8 80 0E		ldr  r0, ptc_addr
 478 01CA 01 2B		strb r1, [ r0, #pTC_TIR ]
 479           		; Epilogo
 480 01CC 02 04		pop		r2
 481 01CE 01 04		pop		r1
 482 01D0 00 04		pop		r0
 483 01D2 20 B0		movs	pc, lr
 484           		
 485           		
 486           	timer_clearInterrupt:
 487 01D4 00 60		mov r0, 0
 488 01D6 21 0C		ldr r1, timer_addressr
 489 01D8 10 2B		strb r0, [ r1, #pTC_TIR ]
 490 01DA 0F B7		mov pc, lr
 491           		
 492           		
 493           	timer_addressr:
 494 01DC 40 FF		.word  pTC_ADDRESS	
 495           	;-------------------------------------------------------------------------
 496           	;Funcao para devolver o valor corrente da variável global ticks.
 497           	;uint16_t sysclk_get_value ( void );
 498           	;	return ticks;
 499           	;-------------------------------------------------------------------------
 500           	sysclk_get_value:
 501 01DE 61 0C		ldr		r1, ticks_addr
 502 01E0 10 00		ldr  	r0, [r1, #0] 	; r0 = ticks
 503 01E2 0F B7		mov		pc, lr
 504           	
 505           	;-------------------------------------------------------------------------
 506           	;Funcao para devolver o tempo decorrido desde o instante last_read. 
 507           	;O tempo e medido em unidades de contagem ( ticks ).
 508           	;uint8_t sysclk_elapsed ( uint16_t last_read ){
 509           	;	return ( ticks - last_read )
 510           	;}
 511           	;-------------------------------------------------------------------------
 512           	sysclk_elapsed:
 513 01E4 31 0C		ldr	 r1, ticks_addr
 514 01E6 12 00		ldr  r2, [r1, #0] 	; r0 = ticks
 515 01E8 20 88		sub  r0, r2, r0
 516 01EA 0F B7		mov  pc,lr
 517           	
 518           	ticks_addr:
 519 01EC C0 02		.word ticks
 520           		
 521           	;-------------------------------------------------------------------------
 522           	;Funcao para iniciar a contagem no periferico.
 523           	;void timer_start ( void );
 524           	;-------------------------------------------------------------------------
 525           	timer_start:
 526 01EE 01 60		mov  r1, #pTC_CMD_START
 527 01F0 40 0D		ldr  r0, ptc_addr
 528 01F2 01 28		strb r1, [ r0, #pTC_TCR ]
 529 01F4 0F B7		mov  pc, lr
 530           	
 531           	
 532           	timer_write:
 533 01F6 32 0C		ldr 	r2, timer_addressrc
 534 01F8 00 80		add		r0, r0, r0
 535 01FA 21 38		strb 	r1, [r2,r0]	
 536 01FC 0F B7		mov		pc,lr
 537           	
 538           	timer_addressrc:
 539 01FE 40 FF		.word  pTC_ADDRESS	
 540           	;-------------------------------------------------------------------------
 541           	;Funcao para parar a contagem no periferico. 
 542           	;Colocando o contador com o valor zero.
 543           	;void timer_stop ( void );
 544           	;-------------------------------------------------------------------------
 545           	timer_stop:
 546 0200 11 60		mov  r1, #pTC_CMD_STOP
 547 0202 B0 0C		ldr  r0, ptc_addr
 548 0204 01 28		strb r1, [ r0, #pTC_TCR ]
 549 0206 0F B7		mov  pc, lr
 550           	
 551           	;-------------------------------------------------------------------------
 552           	;Funcao que faz a iniciacao do periferico para habilitar o 
 553           	;funcionamento em modo continuo e com intervalo de contagem 
 554           	;interval, em ticks.
 555           	;void timer_init ( uint8_t interval );
 556           	;-------------------------------------------------------------------------
 557           	timer_init:
 558 0208 0E 24		push lr
 559 020A 00 24		push r0				
 560           		; Parar contagem
 561 020C F9 5F		bl   timer_stop
 562           		; Programar intervalo de contagem
 563 020E 00 04		pop	 r0
 564 0210 41 0C		ldr  r1, ptc_addr
 565 0212 10 29		strb r0, [ r1, #pTC_TMR ]
 566           		; Clear Interrupt Request
 567 0214 21 0C		ldr  r1, ptc_addr
 568 0216 10 2B		strb r0, [ r1, #pTC_TIR ]
 569 0218 0F 04		pop  pc
 570           		
 571           	ptc_addr:
 572 021A 40 FF		.word pTC_ADDRESS
 573           	
 574           	;---------------------------------------------------------------------------------	
 575           	;uint8_t sw_is_pressed(uint8_t pin_mask) {
 576           	;uint8_t sw_new_state;
 577           	;   sw_new_state = inport_test_bits( pin_mask );
 578           	;	if ( sw_state == sw_new_state )
 579           	;		return 0;
 580           	;	sw_state = sw_new_state;
 581           	;   if ( sw_new_state == 0 )
 582           	;		return 0;
 583           	;	return 1;
 584           	;}
 585           	;---------------------------------------------------------------------------------	
 586           	; Rotina:    sw_is_pressed
 587           	; Descricao: 
 588           	; Entradas:  pins_mask
 589           	; Saidas:    devolve 1 se detecta uma transição 0 -> 1 no pino identificado em pin_mask 
 590           	;            e 0 se não detecta.   
 591           	; Efeitos:   
 592           	;---------------------------------------------------------------------------------	
 593           	sw_is_pressed:
 594 021C 0E 24		push	lr
 595 021E 17 5C		bl		inport_test_bits 
 596           		; r0 = sw_new_state = inport_test_bits(pins_mask)
 597 0220 A1 0C		ldr		r1, sw_state_address
 598 0222 12 08		ldrb	r2, [r1, #0]	; r2 = sw_state
 599 0224 00 B9		cmp		r0, r2			; sw_state == sw_new_state
 600 0226 05 40		beq		sw_is_pressed_0
 601 0228 10 28		strb	r0, [r1, #0]	; sw_state = sw_new_state;
 602 022A 00 A8		sub		r0, r0, #0
 603 022C 02 40		beq		sw_is_pressed_0
 604 022E 10 60		mov		r0, #1
 605 0230 01 58		b		sw_is_pressed_1
 606           	sw_is_pressed_0:
 607 0232 00 60		mov		r0, #0
 608           	sw_is_pressed_1:
 609 0234 0F 04		pop		pc
 610           	
 611           	sw_state_address:
 612 0236 C8 02		.word	sw_state
 613           	
 614           	
 615           	reset_all:
 616 0238 0E 24		push	lr
 617 023A E2 5F		bl timer_stop
 618           		;timer sysclk  = 0	
 619 023C 61 0C		ldr		r1, ticks_addr_reset
 620 023E 00 60		mov r0, 0
 621 0240 10 20		str		r0, [r1, #0]	
 622           		
 623 0242 41 0C		ldr		r1, score_addr_reset
 624 0244 00 60		mov r0, 0
 625 0246 10 20		str		r0, [r1, #0]	
 626           		
 627 0248 0F 04		pop		pc
 628           		
 629           	ticks_addr_reset:
 630 024A C0 02		.word 	ticks
 631           		
 632           	score_addr_reset:
 633 024C BE 02		.word	score
 634           	;---------------------------------------------------------------------------------	
 635           	;uint16_t inport_test_bits(uint16_t pins_mask) {
 636           	;	return ((inport_read() & pins_mask) == pins_mask);
 637           	;}
 638           	;---------------------------------------------------------------------------------	
 639           	; Rotina:    inport_test_bits
 640           	; Descricao: Devolve um se todos dos pinos do porto de entrada identificados com o valor um
 641           	; em pins_mask tomaremm o valor logico um , ou zero no caso contrario .
 642           	; Entradas:  Mascara com os bits a testar
 643           	; Saidas:    Devolve um ou zero conforme a descrição.
 644           	; Efeitos:   
 645           	;---------------------------------------------------------------------------------	
 646           	inport_test_bits:
 647 024E 0E 24		push	lr
 648 0250 04 24		push	r4
 649 0252 04 B0		mov		r4, r0
 650 0254 08 5C		bl		inport_read
 651 0256 00 C2		and		r0, r0, r4
 652 0258 00 BA		cmp     r0, r4
 653 025A 02 40		beq		end_inport_test_bit_1
 654 025C 00 60		mov		r0, #0
 655 025E 01 58		b		end_inport_test_bit
 656           	end_inport_test_bit_1:
 657 0260 10 60		mov		r0, #1
 658           	end_inport_test_bit:
 659 0262 04 04		pop		r4
 660 0264 0F 04		pop		pc
 661           		
 662           	;---------------------------------------------------------------------------------	
 663           	;uint16_t inport_read() {
 664           	;	return [INPORT_ADDRESS];
 665           	;}
 666           	;---------------------------------------------------------------------------------	
 667           	; Rotina:    inport_read
 668           	; Descricao: Devolve o valor corrente do estado dos pinos do porto de entrada.
 669           	; Entradas:  
 670           	; Saidas:    Valor corrente do porto
 671           	; Efeitos:   
 672           	;---------------------------------------------------------------------------------	
 673           	inport_read:
 674 0266 20 0C		ldr		r0, inport_address_local
 675 0268 00 08		ldrb	r0, [r0, #0]
 676 026A 0F B7		mov		pc, lr
 677           	
 678           	inport_address_local:
 679 026C 00 FF		.word	INPORT_ADDRESS
 680           	;---------------------------------------------------------------------------------	
 681           	;uint8_t outport_init(uint8_t initial_value) {
 682           	;	outport_img = initial_value;
 683           	;	outport_write(outport_img);
 684           	;}
 685           	;---------------------------------------------------------------------------------	
 686           	; Rotina:    outport_init
 687           	; Descricao: Inicia o porto de saida, atribuindo-lhe o valor do argumento passado 
 688           	;			 a rotina.
 689           	; Entradas:  Valor para iniciar o porto de saida
 690           	; Saidas:    
 691           	; Efeitos:   Atualiza o valor da variavel imagem do porto
 692           	;---------------------------------------------------------------------------------	
 693           	outport_init:
 694 026E 0E 24		push	lr
 695 0270 00 60		mov r0 , #0
 696 0272 F1 0D		ldr		r1, outport_img_address
 697 0274 10 28		strb	r0, [r1, #0]
 698 0276 1A 5C		bl		outport_write
 699 0278 0F 04		pop		pc
 700           	
 701           	;---------------------------------------------------------------------------------	
 702           	;void outport_set_bits(uint8_t pins_mask) {
 703           	;	outport_img |= pins_mask;
 704           	;	ourport_write(outport_img);
 705           	;}
 706           	;---------------------------------------------------------------------------------	
 707           	; Rotina:    outport_set_bits
 708           	; Descricao: Atribui o valor logico '1' aos pinos do porto de saida identificados 
 709           	;			 com o valor 1 no argumento passado a rotina. O estado dos restantes 
 710           	;			 bits nao e alterado.
 711           	; Entradas:  Mascara com os bits a alterar
 712           	; Saidas:    
 713           	; Efeitos:   Atualiza o valor da variavel imagem do porto
 714           	;---------------------------------------------------------------------------------	
 715           	outport_set_bits:
 716 027A 0E 24		push	lr
 717 027C A1 0D		ldr		r1, outport_img_address
 718 027E 12 08		ldrb	r2, [r1, #0]
 719 0280 20 C8		orr		r0, r2, r0
 720 0282 10 28		strb	r0, [r1, #0]
 721 0284 13 5C		bl		outport_write
 722 0286 0F 04		pop		pc
 723           	
 724           	;---------------------------------------------------------------------------------	
 725           	;void outport_clear_bits(uint8_t pins_mask) {
 726           	;	outport_img &= ~pins_mask ;
 727           	;	ourport_write(outport_img);
 728           	;}
 729           	;---------------------------------------------------------------------------------	
 730           	; Rotina:    outport_clear_bits
 731           	; Descricao: Atribui o valor logico '0' aos pinos do porto de saida identificados 
 732           	;			 com o valor 1 no argumento passado a rotina. O estado dos restantes 
 733           	;			 bits nao e alterado.
 734           	; Entradas:  Mascara com os bits a alterar
 735           	; Saidas:    
 736           	; Efeitos:   Atualiza o valor da variavel imagem do porto
 737           	;---------------------------------------------------------------------------------	
 738           	outport_clear_bits:
 739 0288 0E 24		push	lr
 740 028A 31 0D		ldr		r1, outport_img_address
 741 028C 12 08		ldrb	r2, [r1, #0]
 742 028E 10 B0		mvn		r0, r0
 743 0290 20 C0		and		r0, r2, r0
 744 0292 10 28		strb	r0, [r1, #0]
 745 0294 0B 5C		bl		outport_write
 746 0296 0F 04		pop		pc
 747           	
 748           	;---------------------------------------------------------------------------------	
 749           	;void outport_write_bits(uint8_t pins_mask, uint8_t value) {
 750           	;	value &= pins_mask;
 751           	;	outport_img &= ~pins_mask;
 752           	;	outport_img |= value;
 753           	;	ourport_write(outport_img)
 754           	;}
 755           	;---------------------------------------------------------------------------------	
 756           	; Rotina:    outport_write_bits
 757           	; Descricao: Atribui aos pinos do porto de saida identificados com o valor lógico
 758           	;            um em pins_mask o valor dos bits correspondentes de value. O estado 
 759           	;            dos restantes bits nao e alterado.
 760           	; Entradas:  Mascara com os bits a alterar
 761           	;         :  valor dos bits a alterar  
 762           	; Saidas:    
 763           	; Efeitos:   Atualiza o valor da variavel imagem do porto
 764           	;---------------------------------------------------------------------------------	
 765           	outport_write_bits:
 766 0298 0E 24		push	lr
 767 029A 81 C0		and		r1, r0, r1				; r1 = pins_mask & value
 768 029C A2 0C		ldr		r2, outport_img_address
 769 029E 23 08		ldrb	r3, [r2, #0]
 770 02A0 10 B0		mvn		r0, r0					; ~pins_mask
 771 02A2 33 C0		and		r3, r3, r0				; outport_img &= ~pins_mask;
 772 02A4 B0 C8		orr		r0, r3, r1				; outport_img |= pins_mask & value;
 773 02A6 20 28		strb	r0, [r2, #0]
 774 02A8 01 5C		bl		outport_write
 775 02AA 0F 04		pop		pc
 776           	
 777           	;---------------------------------------------------------------------------------	
 778           	;void outport_write(uint8_t value) {
 779           	;	outport_img = value;
 780           	;	[OUTPORT_ADDRESS] = outport_img;
 781           	;}
 782           	;---------------------------------------------------------------------------------	
 783           	; Rotina:    outport_write
 784           	; Descricao: Atribui aos pinos do porto de saida o valor dos bits correspondentes de value.
 785           	; Entradas:  Valor a escrever no porto
 786           	; Saidas:    
 787           	; Efeitos:   Atualiza o valor da variavel imagem do porto
 788           	;---------------------------------------------------------------------------------	
 789           	outport_write:
 790 02AC 31 0C		ldr		r1, outport_addr
 791 02AE 10 28		strb	r0, [r1, #0]
 792 02B0 0F B7		mov		pc, lr
 793           	
 794           	outport_img_address:
 795 02B2 CA 02		.word	outport_img
 796           	
 797           	outport_addr:
 798 02B4 00 FF		.word	OUTPORT_ADDRESS
 799           		
 800           	; Seccao:    .data
 801           	; Descricao: Guarda as variáveis globais com valor inicial definido
 802           	;
 803           		.data
 804           	timer_level:
 805 02B6 00 00		.word	0
 806           		
 807           	timer_1s:
 808 02B8 00 00		.word	0
 809           		
 810           	timer_5s:
 811 02BA 00 00		.word	0
 812           		
 813           	current_lvl_dificult_in_time:
 814 02BC 0A 00		.word	10
 815           	
 816           	score:
 817 02BE 00 00		.word	0
 818           		
 819           	ticks:
 820 02C0 00 00		.word	0		; uint16_t ticks;
 821           		
 822           	ball_pos:
 823 02C2 80		.byte	0x80
 824           	lvl_in_time:
 825           		.byte	20, 10, 5		; 1s / 0.5s / 0.25s
 825 02C3 14 0A 05
 826           	
 827           	new_point_led:
 828 02C6 00		.byte	0x00
 829           		
 830           	direction: ; 0 away from player 1 into the player
 831 02C7 00		.byte	0x00
 832           	sw_state:
 833 02C8 00		.byte 	0
 834           	; Seccao:    .bss
 835           	; Descricao: Guarda as variáveis globais sem valor inicial definido
 836           	;
 837           		.section .bss
 838           	outport_img:			; Imagem do porto de saida no programa
 839 02CA 00   		.space	1	
 840           	
 841           	; Seccao:    .stack
 842           	; Descricao: Implementa a pilha com o tamanho definido pelo simbolo STACK_SIZE
 843           	;
 844           		.section .stack
 845 02CC 00   		.space STACK_SIZE
 845 .... ..
 845 030B 00
 846           	tos:
