P16 assembler v1.3.2 (May  7 2020)	tp4.lst	Thu Jun 16 00:59:41 2022

Sections
Index   Name            Addresses       Size
0       .startup        0000 - 000F     0010 16
1       .text           0010 - 023D     022E 558
2       .data           023E - 024B     000E 14
3       .bss            024C - 024C     0001 1
4       .stack          024E - 028D     0040 64

Symbols
Name                    Type      Value      Section
_start                  LABEL     0004 4     .startup
add_score               LABEL     0126 294   .text
BALL_LEDS_MASK          ABSOLUTE  00FE 254   .startup
ball_pos                LABEL     0248 584   .data
ball_pos_addr           LABEL     0124 292   .text
ball_pos_addr_cc        LABEL     0154 340   .text
ball_pos_addr_ddd       LABEL     0030 48    .text
ball_pos_addrb          LABEL     00FA 250   .text
CPSR_BIT_I              ABSOLUTE  0010 16    .startup
current_lvl_dificult_in_time LABEL     0242 578   .data
direction               LABEL     024A 586   .data
direction_addr          LABEL     00D8 216   .text
direction_addr_bb       LABEL     0152 338   .text
direction_addr_cc       LABEL     0040 64    .text
end_inport_test_bit     LABEL     01EA 490   .text
end_inport_test_bit_1   LABEL     01E8 488   .text
finish_mov              LABEL     014C 332   .text
game_loop               LABEL     0058 88    .text
game_over               LABEL     00C4 196   .text
game_over_skip          LABEL     0098 152   .text
IE_MASK                 ABSOLUTE  0010 16    .startup
init_timer_1s           LABEL     010C 268   .text
init_timer_lvl          LABEL     0118 280   .text
INPORT_ADDRESS          ABSOLUTE  FF00 65280 .startup
inport_address_local    LABEL     01F4 500   .text
inport_read             LABEL     01EE 494   .text
inport_test_bits        LABEL     01D6 470   .text
invert_dir              LABEL     00CA 202   .text
isr                     LABEL     0156 342   .text
isr_addr                LABEL     000E 14    .startup
LED0_MASK               ABSOLUTE  0001 1     .startup
level_up_skip           LABEL     00A8 168   .text
main                    LABEL     0034 52    .text
main_addr               LABEL     000C 12    .startup
main_while              LABEL     0042 66    .text
mov_away                LABEL     014A 330   .text
mov_ball                LABEL     0134 308   .text
new_point_led           LABEL     0249 585   .data
new_point_led_addr      LABEL     00DA 218   .text
new_point_led_addrbbb   LABEL     010A 266   .text
NEW_POINT_LED_MASK      ABSOLUTE  0001 1     .startup
one_second_pass         LABEL     00DE 222   .text
one_second_pass_spik    LABEL     0066 102   .text
outport_addr            LABEL     023C 572   .text
OUTPORT_ADDRESS         ABSOLUTE  FF00 65280 .startup
outport_clear_bits      LABEL     0210 528   .text
outport_img             LABEL     024C 588   .bss
outport_img_address     LABEL     023A 570   .text
outport_init            LABEL     01F6 502   .text
OUTPORT_INIT_VALUE      ABSOLUTE  0000 0     .startup
outport_set_bits        LABEL     0202 514   .text
outport_write           LABEL     0234 564   .text
outport_write_bits      LABEL     0220 544   .text
PLAYER_MASK             ABSOLUTE  0080 128   .startup
ptc_addr                LABEL     01B8 440   .text
pTC_ADDRESS             ABSOLUTE  FF40 65344 .startup
pTC_CMD_START           ABSOLUTE  0000 0     .startup
pTC_CMD_STOP            ABSOLUTE  0001 1     .startup
pTC_TC                  ABSOLUTE  0004 4     .startup
pTC_TCR                 ABSOLUTE  0000 0     .startup
pTC_TIR                 ABSOLUTE  0006 6     .startup
pTC_TMR                 ABSOLUTE  0002 2     .startup
RAKET_MASK              ABSOLUTE  0001 1     .startup
score                   LABEL     0244 580   .data
score_addr              LABEL     00DC 220   .text
score_addr_bb           LABEL     0132 306   .text
set_ball_leds           LABEL     00EC 236   .text
set_led_newpoint        LABEL     00FC 252   .text
skip_invert_dir         LABEL     00A2 162   .text
STACK_SIZE              ABSOLUTE  0040 64    .startup
start_game              LABEL     004E 78    .text
sw_is_pressed           LABEL     01BA 442   .text
sw_is_pressed_0         LABEL     01D0 464   .text
sw_is_pressed_1         LABEL     01D2 466   .text
sw_state                LABEL     024B 587   .data
sw_state_address        LABEL     01D4 468   .text
SYS_init                LABEL     0010 16    .text
sysclk_elapsed          LABEL     0182 386   .text
SYSCLK_FREQ             ABSOLUTE  0005 5     .startup
sysclk_get_value        LABEL     017C 380   .text
ticks                   LABEL     0246 582   .data
ticks_addr              LABEL     018A 394   .text
ticks_addrb             LABEL     0032 50    .text
time_lvl                LABEL     007E 126   .text
timer_1s                LABEL     0240 576   .data
timer_1s_adrr           LABEL     00F8 248   .text
timer_1s_adrrb          LABEL     0116 278   .text
timer_1s_adrrvv         LABEL     00C8 200   .text
timer_addressr          LABEL     017A 378   .text
timer_addressrc         LABEL     019C 412   .text
timer_clearInterrupt    LABEL     0172 370   .text
timer_init              LABEL     01A6 422   .text
timer_level             LABEL     023E 574   .data
timer_level_adrr        LABEL     00EA 234   .text
timer_level_adrrb       LABEL     0122 290   .text
timer_start             LABEL     018C 396   .text
timer_stop              LABEL     019E 414   .text
timer_write             LABEL     0194 404   .text
tos                     LABEL     028E 654   .stack
tos_addr                LABEL     000A 10    .startup
VALU_OF_1S              ABSOLUTE  000C 12    .startup
VALU_OF_25              ABSOLUTE  0003 3     .startup
wait_for_init_stroke    LABEL     0044 68    .text
WALL_MASK               ABSOLUTE  0002 2     .startup

Code listing
   1           	; Ficheiro:  p16_extint_demo.S
   2           	; Descricao: Programa para exemplificar o funcionamento do sistema de
   3           	;            interrupcoes do processador P16.
   4           	; Autor:     
   5           	; Data:      03-01-2022
   6           	
   7           	; Definicao dos valores dos simbolos utilizados no programa
   8           	;
   9          		.equ	STACK_SIZE, 64             ; Dimensao do stack (em bytes)
  10           	
  11          		.equ    INPORT_ADDRESS, 0xFF00  ; Endereço do porto de entrada da placa SDP16
  12          		.equ	OUTPORT_ADDRESS, 0xFF00 ; Endereço do porto de saida da placa SDP16
  13           	
  14          		.equ	CPSR_BIT_I, 0x10          ; Mascara para a flag I do registo CPSR
  15           	
  16          		.equ	SYSCLK_FREQ, 0x5          ; Intervalo de contagem do circuito pTC
  17           	                                          ; que suporta a implementação do sysclk
  18           											  ; fin_pTC = 10Hz fout_ptc=2Hz => T=500ms 
  19           											  ; TMR = 10Hz/2Hz = 5
  20          		.equ 	LED0_MASK, 0x01
  21          		.equ 	OUTPORT_INIT_VALUE, 0x00
  22           	
  23          		.equ 	IE_MASK,0x10
  24           	
  25          		.equ    pTC_ADDRESS, 0XFF40
  26          		.equ    pTC_TCR, 0
  27          		.equ    pTC_TMR, 2
  28          		.equ    pTC_TC,  4
  29          		.equ    pTC_TIR, 6
  30           		
  31          		.equ    pTC_CMD_STOP,  1
  32          		.equ    pTC_CMD_START, 0
  33           	
  34          		.equ 	PLAYER_MASK, 0X80
  35          		.equ	WALL_MASK,   0X02
  36          		.equ 	NEW_POINT_LED_MASK, 0X1
  37          		.equ	BALL_LEDS_MASK, 0xfe
  38          		.equ 	RAKET_MASK, 0x01
  39          		.equ	VALU_OF_1S, 0x0c
  40          		.equ	VALU_OF_25, 0x03
  41           	; Seccao:    .startup
  42           	; Descricao: Guarda o código de arranque do sistema
  43           	;
  44           		.section .startup
  45 0000 01 58		b 	_start
  46 0002 5F 0C		ldr	pc, isr_addr
  47           	
  48           	_start:
  49 0004 2D 0C		ldr sp, tos_addr
  50 0006 04 5C		bl SYS_init
  51 0008 1F 0C		ldr	pc, main_addr
  52           	
  53           	tos_addr:
  54 000A 8E 02		.word	tos
  55           	main_addr:
  56 000C 34 00		.word	main
  57           	isr_addr:
  58 000E 56 01		.word	isr
  59           		
  60           	;----------------------------------------	
  61           	;# define OUTPORT_INIT_VALUE 0
  62           	;# define LED0_MASK 1
  63           	;
  64           	;uint16_t ticks = 0;
  65           	; 
  66           	;void main() {
  67           	;uint16_t t;
  68           	;	outport_init ( OUTPORT_INIT_VALUE );
  69           	;	timer_init ( SYSCLK_FREQ );
  70           	;   //Habilitar o atendimento das interrupcoes
  71           	;   while(1) {
  72           	;		outport_set_bits(LED0_MASK);
  73           	;		t = sysclk_get_value ();
  74           	;		while ( sysclk_elapsed ( t ) < LED_TOGGLE_TIME );
  75           	;		outport_clear_bits(LED0_MASK);
  76           	;		t = sysclk_get_value ();
  77           	;		while ( sysclk_elapsed ( t ) < LED_TOGGLE_TIME );
  78           	;   }
  79           	;}
  80           	;----------------------------------------	
  81           		.text
  82           	SYS_init:
  83 0010 0E 24		push lr
  84 0012 F1 5C		bl outport_init		
  85 0014 C4 5C		bl timer_stop
  86 0016 D0 0C		ldr		r0, ticks_addrb
  87 0018 01 00		ldr		r1, [r0, #0]
  88 001A 01 60		mov		r1,  #0
  89 001C 01 20		str		r1, [r0, #0]
  90 001E 00 68		mov r0, 0x80
  91 0020 71 0C		ldr r1, ball_pos_addr_ddd
  92 0022 10 28		strb r0, [r1]
  93           		
  94           		
  95 0024 10 60		mov r0, #1
  96 0026 01 6E		mov r1, 0xE0
  97 0028 B5 5C		bl timer_write		
  98           		;bl timer_clearInterrupt	
  99           	
 100           	
 101           	
 102 002A 00 61		mov r0, IE_MASK
 103           	
 104 002C 40 B0		msr cpsr, r0	
 105 002E 0F 04		pop pc	
 106           		
 107           	ball_pos_addr_ddd:
 108 0030 48 02		.word 	ball_pos	
 109           		
 110           	ticks_addrb:
 111 0032 46 02		.word ticks
 112           	
 113           	main:
 114 0034 0E 24		push lr	
 115 0036 B3 5C		bl timer_stop
 116 0038 30 0C		ldr r0, direction_addr_cc
 117 003A 01 60		mov r1, 0
 118 003C 01 28		strb r1, [r0]
 119 003E 01 58		b main_while
 120           		
 121           	direction_addr_cc:
 122 0040 4A 02		.word	direction
 123           		
 124           	main_while:
 125 0042 54 5C		bl set_ball_leds
 126           		
 127           	wait_for_init_stroke:
 128 0044 10 60		mov r0, RAKET_MASK
 129 0046 B9 5C		bl sw_is_pressed
 130 0048 00 A0		add r0,r0,0
 131 004A 01 44		bzc start_game  
 132 004C FB 5B		b    wait_for_init_stroke
 133           	start_game:		
 134 004E 9E 5C		bl timer_start
 135 0050 63 5C		bl init_timer_lvl
 136 0052 5C 5C		bl init_timer_1s
 137 0054 6F 5C		bl mov_ball
 138 0056 4A 5C		bl set_ball_leds
 139           	game_loop:
 140           	
 141 0058 71 0F		ldr r1, timer_1s_adrrvv
 142 005A 10 00		ldr r0, [r1]
 143 005C 92 5C		bl sysclk_elapsed
 144 005E C1 60		mov r1, VALU_OF_1S
 145 0060 80 B8		cmp r0, r1 ;20
 146 0062 01 48		blo one_second_pass_spik
 147 0064 3C 5C		bl one_second_pass
 148           	one_second_pass_spik:	
 149 0066 90 0F		ldr r0, new_point_led_addr
 150 0068 00 08		ldrb r0,[r0]
 151 006A 00 A8		sub r0,r0,0
 152 006C 08 40		bzs time_lvl
 153           		
 154 006E C1 0E		ldr r1, timer_1s_adrrvv
 155 0070 10 00		ldr r0, [r1]
 156 0072 87 5C		bl sysclk_elapsed
 157 0074 31 60		mov r1, VALU_OF_25
 158 0076 80 B8		cmp r0, r1 ;20
 159 0078 02 48		blo	time_lvl	
 160 007A 00 60		mov r0, 0
 161 007C 3F 5C		bl set_led_newpoint
 162           		
 163           	
 164           		
 165           	time_lvl:	
 166 007E 51 0F		ldr r1, timer_level_adrr
 167 0080 10 00		ldr r0, [r1]
 168 0082 7F 5C		bl sysclk_elapsed
 169 0084 D1 60		mov r1, 0x0d ;TODO GET TIME OF LEVEL FROM A VAR-----------------
 170 0086 80 B8		cmp r0, r1 ;20	
 171 0088 0F 48		blo level_up_skip
 172           		
 173 008A 46 5C		bl init_timer_lvl 
 174 008C 60 0F		ldr r0, ball_pos_addrb
 175 008E 00 08		ldrb r0, [r0]
 176 0090 02 68		mov r2, PLAYER_MASK
 177 0092 00 89		sub r0, r0, r2
 178 0094 01 44		bzc game_over_skip
 179 0096 16 58		b game_over
 180           	game_over_skip:
 181 0098 00 0F		ldr r0, ball_pos_addrb
 182 009A 00 08		ldrb r0, [r0]
 183           		;mov r2, WALL_MASK
 184 009C 00 A9		sub r0, r0, WALL_MASK
 185 009E 01 44		bzc skip_invert_dir
 186 00A0 14 5C		bl invert_dir
 187           	skip_invert_dir:
 188 00A2 48 5C		bl mov_ball
 189 00A4 23 5C		bl set_ball_leds
 190 00A6 38 5C		bl init_timer_lvl
 191           		
 192           	level_up_skip:	
 193           		;ball in wall ?
 194           	
 195           	;	bl mov_ball
 196           	;	bl set_ball_leds
 197           	
 198           		;ball in player? 
 199 00A8 80 0E		ldr r0, ball_pos_addrb
 200 00AA 00 08		ldrb r0, [r0]
 201 00AC 02 68		mov r2, PLAYER_MASK
 202 00AE 00 89		sub r0, r0, r2	
 203 00B0 D3 47		bzc game_loop
 204           		;raket? 
 205 00B2 10 60		mov r0, RAKET_MASK
 206 00B4 82 5C		bl sw_is_pressed
 207 00B6 00 A0		add r0,r0,0
 208 00B8 CF 43		bzs  game_loop
 209           		
 210 00BA 07 5C		bl invert_dir
 211 00BC 2D 5C		bl init_timer_lvl	
 212 00BE 3A 5C		bl mov_ball
 213 00C0 15 5C		bl set_ball_leds
 214           		
 215 00C2 CA 5B		b game_loop
 216           		
 217           	game_over:	
 218 00C4 02 5C		bl invert_dir
 219 00C6 BD 5B		b  main_while 	
 220           		
 221           	timer_1s_adrrvv:
 222 00C8 40 02		.word 	timer_1s		
 223           		
 224           		
 225           	invert_dir:
 226 00CA 0E 24		push lr
 227 00CC 50 0C		ldr r0, direction_addr
 228 00CE 01 08		ldrb r1, [r0]
 229 00D0 12 60		mov r2, 1
 230 00D2 11 D1		eor r1, r1, r2
 231 00D4 01 28		strb r1, [r0]
 232 00D6 0F 04		pop pc
 233           		
 234           	direction_addr:
 235 00D8 4A 02		.word	direction
 236           		
 237           	new_point_led_addr:
 238 00DA 49 02		.word 	new_point_led
 239           	
 240           	
 241           		
 242           		
 243           			
 244           	score_addr:
 245 00DC 44 02		.word 	score
 246           		
 247           	one_second_pass:
 248           		;SCORE ++
 249           		;LED ON NEW POINT
 250           		;INIT TIMER
 251 00DE 0E 24		push lr
 252 00E0 15 5C		bl init_timer_1s
 253 00E2 10 60		mov r0, 1
 254 00E4 0B 5C		bl set_led_newpoint
 255 00E6 1F 5C		bl add_score
 256 00E8 0F 04		pop pc
 257           		
 258           	timer_level_adrr:
 259 00EA 3E 02		.word timer_level
 260           	
 261           	set_ball_leds:
 262 00EC 0E 24		push lr	
 263 00EE 51 0C		ldr	r1, ball_pos_addrb
 264 00F0 11 08		ldrb r1, [r1]
 265 00F2 E0 6F		mov r0, BALL_LEDS_MASK
 266 00F4 95 5C		bl	outport_write_bits	
 267 00F6 0F 04		pop pc
 268           		
 269           	timer_1s_adrr:
 270 00F8 40 02		.word 	timer_1s	
 271           		
 272           	ball_pos_addrb:
 273 00FA 48 02		.word 	ball_pos	
 274           	; set led new point to the valu of r0	
 275           	set_led_newpoint:
 276 00FC 0E 24		push lr
 277 00FE 51 0C		ldr r1, new_point_led_addrbbb
 278 0100 10 28		strb r0, [r1]
 279 0102 01 B0		mov r1,r0
 280 0104 10 60		mov r0, NEW_POINT_LED_MASK
 281 0106 8C 5C		bl	outport_write_bits
 282 0108 0F 04		pop pc
 283           		
 284           	new_point_led_addrbbb:
 285 010A 49 02			.word	new_point_led
 286           	
 287           		
 288           	init_timer_1s:
 289 010C 0E 24		push lr
 290 010E 36 5C		bl sysclk_get_value	
 291 0110 21 0C		ldr r1, timer_1s_adrrb
 292 0112 10 20		str r0, [r1]	
 293 0114 0F 04		pop pc
 294           		
 295           	timer_1s_adrrb:
 296 0116 40 02		.word 	timer_1s	
 297           		
 298           	init_timer_lvl:
 299 0118 0E 24		push lr
 300 011A 30 5C		bl sysclk_get_value	
 301 011C 21 0C		ldr r1, timer_level_adrrb
 302 011E 10 20		str r0, [r1]	
 303 0120 0F 04		pop pc
 304           		
 305           		
 306           	
 307           	
 308           	timer_level_adrrb:
 309 0122 3E 02		.word timer_level
 310           	
 311           	
 312           	
 313           	
 314           		
 315           	
 316           	
 317           	
 318           	
 319           	ball_pos_addr:
 320 0124 48 02		.word 	ball_pos
 321           		
 322           	
 323           		
 324           	add_score:	
 325 0126 0E 24		push lr
 326 0128 40 0C		ldr r0, score_addr_bb
 327 012A 01 00		ldr r1, [r0]
 328 012C 91 A0		add r1, r1, 1
 329 012E 01 20		str r1, [r0]
 330 0130 0F 04		pop pc
 331           	;	mov pc, lr
 332           		
 333           	score_addr_bb:
 334 0132 44 02		.word score
 335           	;-------------------------------------------------------------------------
 336           	; Rotina:    mov_ball
 337           	; Descricao: R
 338           	; Entradas:  -
 339           	; Saidas:    -
 340           	; Efeitos:   
 341           	; void mov_ball() {
 342           	;   
 343           	;}	
 344           	mov_ball:
 345 0134 0E 24		push lr
 346 0136 E0 0C		ldr r0, ball_pos_addr_cc
 347 0138 00 08		ldrb r0, [r0]	
 348 013A B1 0C		ldr r1, direction_addr_bb
 349 013C 11 08		ldrb r1, [r1]
 350 013E 12 60		mov r2, 1
 351 0140 11 C1		and r1,r1,r2
 352 0142 11 A8		sub r1, r1, 0	
 353 0144 02 40		bzs mov_away
 354           		;move from wall to player (BALL_POS6)01 -> (BALL_POS0)07   
 355 0146 80 E0		lsl r0, r0,1	
 356 0148 01 58		b finish_mov
 357           	mov_away:
 358 014A 80 E8		lsr r0, r0,1
 359           		
 360           	finish_mov:
 361 014C 31 0C		ldr r1, ball_pos_addr_cc
 362 014E 10 28		strb r0, [r1]
 363           		
 364 0150 0F 04		pop pc
 365           		
 366           		
 367           	direction_addr_bb:
 368 0152 4A 02		.word direction
 369           		
 370           	ball_pos_addr_cc:
 371 0154 48 02			.word ball_pos
 372           	
 373           	;-------------------------------------------------------------------------
 374           	; Rotina:    isr
 375           	; Descricao: Rotina responsavel pelo processamento do pedido de interrupcao.
 376           	; Entradas:  -
 377           	; Saidas:    -
 378           	; Efeitos:   Incrementa o valor da variavel global ticks
 379           	; void isr() {
 380           	;   ticks++;
 381           	;	//clear Interrupt Request
 382           	;}
 383           	isr:
 384           		; Prologo
 385 0156 00 24		push	r0
 386 0158 01 24		push	r1
 387 015A 02 24		push	r2
 388           		; Corpo da rotina
 389 015C 60 0D		ldr		r0, ticks_addr
 390 015E 01 00		ldr		r1, [r0, #0]
 391 0160 91 A0		add		r1, r1, #1
 392 0162 01 20		str		r1, [r0, #0]
 393           		; clear Interrupt Request
 394           		;bl 	timer_clearInterrupt
 395 0164 F1 6F		mov r1, 0xFF
 396 0166 80 0E		ldr  r0, ptc_addr
 397 0168 01 2B		strb r1, [ r0, #pTC_TIR ]
 398           		;bl timer_write	
 399           		; Epilogo
 400 016A 02 04		pop		r2
 401 016C 01 04		pop		r1
 402 016E 00 04		pop		r0
 403 0170 20 B0		movs	pc, lr
 404           		
 405           	
 406           		
 407           	timer_clearInterrupt:
 408 0172 00 60		mov r0, 0
 409 0174 21 0C		ldr r1, timer_addressr
 410 0176 10 2B		strb r0, [ r1, #pTC_TIR ]
 411 0178 0F B7		mov pc, lr
 412           		
 413           	timer_addressr:
 414 017A 40 FF		.word  pTC_ADDRESS	
 415           	;-------------------------------------------------------------------------
 416           	;Funcao para devolver o valor corrente da variável global ticks.
 417           	;uint16_t sysclk_get_value ( void );
 418           	;	return ticks;
 419           	;-------------------------------------------------------------------------
 420           	sysclk_get_value:
 421 017C 61 0C		ldr		r1, ticks_addr
 422 017E 10 00		ldr  	r0, [r1, #0] 	; r0 = ticks
 423 0180 0F B7		mov		pc, lr
 424           	
 425           	;-------------------------------------------------------------------------
 426           	;Funcao para devolver o tempo decorrido desde o instante last_read. 
 427           	;O tempo e medido em unidades de contagem ( ticks ).
 428           	;uint8_t sysclk_elapsed ( uint16_t last_read ){
 429           	;	return ( ticks - last_read )
 430           	;}
 431           	;-------------------------------------------------------------------------
 432           	sysclk_elapsed:
 433 0182 31 0C		ldr	 r1, ticks_addr
 434 0184 12 00		ldr  r2, [r1, #0] 	; r0 = ticks
 435 0186 20 88		sub  r0, r2, r0
 436 0188 0F B7		mov  pc,lr
 437           	
 438           	ticks_addr:
 439 018A 46 02		.word ticks
 440           		
 441           	;-------------------------------------------------------------------------
 442           	;Funcao para iniciar a contagem no periferico.
 443           	;void timer_start ( void );
 444           	;-------------------------------------------------------------------------
 445           	timer_start:
 446 018C 01 60		mov  r1, #pTC_CMD_START
 447 018E 40 0D		ldr  r0, ptc_addr
 448 0190 01 28		strb r1, [ r0, #pTC_TCR ]
 449 0192 0F B7		mov  pc, lr
 450           	
 451           	
 452           	timer_write:
 453 0194 32 0C		ldr 	r2, timer_addressrc
 454 0196 00 80		add		r0, r0, r0
 455 0198 21 38		strb 	r1, [r2,r0]	
 456 019A 0F B7		mov		pc,lr
 457           	
 458           	timer_addressrc:
 459 019C 40 FF		.word  pTC_ADDRESS	
 460           	;-------------------------------------------------------------------------
 461           	;Funcao para parar a contagem no periferico. 
 462           	;Colocando o contador com o valor zero.
 463           	;void timer_stop ( void );
 464           	;-------------------------------------------------------------------------
 465           	timer_stop:
 466 019E 11 60		mov  r1, #pTC_CMD_STOP
 467 01A0 B0 0C		ldr  r0, ptc_addr
 468 01A2 01 28		strb r1, [ r0, #pTC_TCR ]
 469 01A4 0F B7		mov  pc, lr
 470           	
 471           	;-------------------------------------------------------------------------
 472           	;Funcao que faz a iniciacao do periferico para habilitar o 
 473           	;funcionamento em modo continuo e com intervalo de contagem 
 474           	;interval, em ticks.
 475           	;void timer_init ( uint8_t interval );
 476           	;-------------------------------------------------------------------------
 477           	timer_init:
 478 01A6 0E 24		push lr
 479 01A8 00 24		push r0				
 480           		; Parar contagem
 481 01AA F9 5F		bl   timer_stop
 482           		; Programar intervalo de contagem
 483 01AC 00 04		pop	 r0
 484 01AE 41 0C		ldr  r1, ptc_addr
 485 01B0 10 29		strb r0, [ r1, #pTC_TMR ]
 486           		; Clear Interrupt Request
 487 01B2 21 0C		ldr  r1, ptc_addr
 488 01B4 10 2B		strb r0, [ r1, #pTC_TIR ]
 489 01B6 0F 04		pop  pc
 490           		
 491           	ptc_addr:
 492 01B8 40 FF		.word pTC_ADDRESS
 493           	
 494           	;---------------------------------------------------------------------------------	
 495           	;uint8_t sw_is_pressed(uint8_t pin_mask) {
 496           	;uint8_t sw_new_state;
 497           	;   sw_new_state = inport_test_bits( pin_mask );
 498           	;	if ( sw_state == sw_new_state )
 499           	;		return 0;
 500           	;	sw_state = sw_new_state;
 501           	;   if ( sw_new_state == 0 )
 502           	;		return 0;
 503           	;	return 1;
 504           	;}
 505           	;---------------------------------------------------------------------------------	
 506           	; Rotina:    sw_is_pressed
 507           	; Descricao: 
 508           	; Entradas:  pins_mask
 509           	; Saidas:    devolve 1 se detecta uma transição 0 -> 1 no pino identificado em pin_mask 
 510           	;            e 0 se não detecta.   
 511           	; Efeitos:   
 512           	;---------------------------------------------------------------------------------	
 513           	sw_is_pressed:
 514 01BA 0E 24		push	lr
 515 01BC 0C 5C		bl		inport_test_bits 
 516           		; r0 = sw_new_state = inport_test_bits(pins_mask)
 517 01BE A1 0C		ldr		r1, sw_state_address
 518 01C0 12 08		ldrb	r2, [r1, #0]	; r2 = sw_state
 519 01C2 00 B9		cmp		r0, r2			; sw_state == sw_new_state
 520 01C4 05 40		beq		sw_is_pressed_0
 521 01C6 10 28		strb	r0, [r1, #0]	; sw_state = sw_new_state;
 522 01C8 00 A8		sub		r0, r0, #0
 523 01CA 02 40		beq		sw_is_pressed_0
 524 01CC 10 60		mov		r0, #1
 525 01CE 01 58		b		sw_is_pressed_1
 526           	sw_is_pressed_0:
 527 01D0 00 60		mov		r0, #0
 528           	sw_is_pressed_1:
 529 01D2 0F 04		pop		pc
 530           	
 531           	sw_state_address:
 532 01D4 4B 02		.word	sw_state
 533           	
 534           	;---------------------------------------------------------------------------------	
 535           	;uint16_t inport_test_bits(uint16_t pins_mask) {
 536           	;	return ((inport_read() & pins_mask) == pins_mask);
 537           	;}
 538           	;---------------------------------------------------------------------------------	
 539           	; Rotina:    inport_test_bits
 540           	; Descricao: Devolve um se todos dos pinos do porto de entrada identificados com o valor um
 541           	; em pins_mask tomaremm o valor logico um , ou zero no caso contrario .
 542           	; Entradas:  Mascara com os bits a testar
 543           	; Saidas:    Devolve um ou zero conforme a descrição.
 544           	; Efeitos:   
 545           	;---------------------------------------------------------------------------------	
 546           	inport_test_bits:
 547 01D6 0E 24		push	lr
 548 01D8 04 24		push	r4
 549 01DA 04 B0		mov		r4, r0
 550 01DC 08 5C		bl		inport_read
 551 01DE 00 C2		and		r0, r0, r4
 552 01E0 00 BA		cmp     r0, r4
 553 01E2 02 40		beq		end_inport_test_bit_1
 554 01E4 00 60		mov		r0, #0
 555 01E6 01 58		b		end_inport_test_bit
 556           	end_inport_test_bit_1:
 557 01E8 10 60		mov		r0, #1
 558           	end_inport_test_bit:
 559 01EA 04 04		pop		r4
 560 01EC 0F 04		pop		pc
 561           		
 562           	;---------------------------------------------------------------------------------	
 563           	;uint16_t inport_read() {
 564           	;	return [INPORT_ADDRESS];
 565           	;}
 566           	;---------------------------------------------------------------------------------	
 567           	; Rotina:    inport_read
 568           	; Descricao: Devolve o valor corrente do estado dos pinos do porto de entrada.
 569           	; Entradas:  
 570           	; Saidas:    Valor corrente do porto
 571           	; Efeitos:   
 572           	;---------------------------------------------------------------------------------	
 573           	inport_read:
 574 01EE 20 0C		ldr		r0, inport_address_local
 575 01F0 00 08		ldrb		r0, [r0, #0]
 576 01F2 0F B7		mov		pc, lr
 577           	
 578           	inport_address_local:
 579 01F4 00 FF		.word	INPORT_ADDRESS
 580           	
 581           	
 582           	
 583           	
 584           	;---------------------------------------------------------------------------------	
 585           	;uint8_t outport_init(uint8_t initial_value) {
 586           	;	outport_img = initial_value;
 587           	;	outport_write(outport_img);
 588           	;}
 589           	;---------------------------------------------------------------------------------	
 590           	; Rotina:    outport_init
 591           	; Descricao: Inicia o porto de saida, atribuindo-lhe o valor do argumento passado 
 592           	;			 a rotina.
 593           	; Entradas:  Valor para iniciar o porto de saida
 594           	; Saidas:    
 595           	; Efeitos:   Atualiza o valor da variavel imagem do porto
 596           	;---------------------------------------------------------------------------------	
 597           	outport_init:
 598 01F6 0E 24		push	lr
 599 01F8 00 60		mov r0 , #0
 600 01FA F1 0D		ldr		r1, outport_img_address
 601 01FC 10 28		strb	r0, [r1, #0]
 602 01FE 1A 5C		bl		outport_write
 603 0200 0F 04		pop		pc
 604           	
 605           	;---------------------------------------------------------------------------------	
 606           	;void outport_set_bits(uint8_t pins_mask) {
 607           	;	outport_img |= pins_mask;
 608           	;	ourport_write(outport_img);
 609           	;}
 610           	;---------------------------------------------------------------------------------	
 611           	; Rotina:    outport_set_bits
 612           	; Descricao: Atribui o valor logico '1' aos pinos do porto de saida identificados 
 613           	;			 com o valor 1 no argumento passado a rotina. O estado dos restantes 
 614           	;			 bits nao e alterado.
 615           	; Entradas:  Mascara com os bits a alterar
 616           	; Saidas:    
 617           	; Efeitos:   Atualiza o valor da variavel imagem do porto
 618           	;---------------------------------------------------------------------------------	
 619           	outport_set_bits:
 620 0202 0E 24		push	lr
 621 0204 A1 0D		ldr		r1, outport_img_address
 622 0206 12 08		ldrb	r2, [r1, #0]
 623 0208 20 C8		orr		r0, r2, r0
 624 020A 10 28		strb	r0, [r1, #0]
 625 020C 13 5C		bl		outport_write
 626 020E 0F 04		pop		pc
 627           	
 628           	;---------------------------------------------------------------------------------	
 629           	;void outport_clear_bits(uint8_t pins_mask) {
 630           	;	outport_img &= ~pins_mask ;
 631           	;	ourport_write(outport_img);
 632           	;}
 633           	;---------------------------------------------------------------------------------	
 634           	; Rotina:    outport_clear_bits
 635           	; Descricao: Atribui o valor logico '0' aos pinos do porto de saida identificados 
 636           	;			 com o valor 1 no argumento passado a rotina. O estado dos restantes 
 637           	;			 bits nao e alterado.
 638           	; Entradas:  Mascara com os bits a alterar
 639           	; Saidas:    
 640           	; Efeitos:   Atualiza o valor da variavel imagem do porto
 641           	;---------------------------------------------------------------------------------	
 642           	outport_clear_bits:
 643 0210 0E 24		push	lr
 644 0212 31 0D		ldr		r1, outport_img_address
 645 0214 12 08		ldrb	r2, [r1, #0]
 646 0216 10 B0		mvn		r0, r0
 647 0218 20 C0		and		r0, r2, r0
 648 021A 10 28		strb	r0, [r1, #0]
 649 021C 0B 5C		bl		outport_write
 650 021E 0F 04		pop		pc
 651           	
 652           	;---------------------------------------------------------------------------------	
 653           	;void outport_write_bits(uint8_t pins_mask, uint8_t value) {
 654           	;	value &= pins_mask;
 655           	;	outport_img &= ~pins_mask;
 656           	;	outport_img |= value;
 657           	;	ourport_write(outport_img)
 658           	;}
 659           	;---------------------------------------------------------------------------------	
 660           	; Rotina:    outport_write_bits
 661           	; Descricao: Atribui aos pinos do porto de saida identificados com o valor lógico
 662           	;            um em pins_mask o valor dos bits correspondentes de value. O estado 
 663           	;            dos restantes bits nao e alterado.
 664           	; Entradas:  Mascara com os bits a alterar
 665           	;         :  valor dos bits a alterar  
 666           	; Saidas:    
 667           	; Efeitos:   Atualiza o valor da variavel imagem do porto
 668           	;---------------------------------------------------------------------------------	
 669           	outport_write_bits:
 670 0220 0E 24		push	lr
 671 0222 81 C0		and		r1, r0, r1				; r1 = pins_mask & value
 672 0224 A2 0C		ldr		r2, outport_img_address
 673 0226 23 08		ldrb	r3, [r2, #0]
 674 0228 10 B0		mvn		r0, r0					; ~pins_mask
 675 022A 33 C0		and		r3, r3, r0				; outport_img &= ~pins_mask;
 676 022C B0 C8		orr		r0, r3, r1				; outport_img |= pins_mask & value;
 677 022E 20 28		strb	r0, [r2, #0]
 678 0230 01 5C		bl		outport_write
 679 0232 0F 04		pop		pc
 680           	
 681           	;---------------------------------------------------------------------------------	
 682           	;void outport_write(uint8_t value) {
 683           	;	outport_img = value;
 684           	;	[OUTPORT_ADDRESS] = outport_img;
 685           	;}
 686           	;---------------------------------------------------------------------------------	
 687           	; Rotina:    outport_write
 688           	; Descricao: Atribui aos pinos do porto de saida o valor dos bits correspondentes de value.
 689           	; Entradas:  Valor a escrever no porto
 690           	; Saidas:    
 691           	; Efeitos:   Atualiza o valor da variavel imagem do porto
 692           	;---------------------------------------------------------------------------------	
 693           	outport_write:
 694 0234 31 0C		ldr		r1, outport_addr
 695 0236 10 28		strb	r0, [r1, #0]
 696 0238 0F B7		mov		pc, lr
 697           	
 698           	outport_img_address:
 699 023A 4C 02		.word	outport_img
 700           	
 701           	outport_addr:
 702 023C 00 FF		.word	OUTPORT_ADDRESS
 703           		
 704           	; Seccao:    .data
 705           	; Descricao: Guarda as variáveis globais com valor inicial definido
 706           	;
 707           		.data
 708           	timer_level:
 709 023E 00 00		.word	0
 710           		
 711           	timer_1s:
 712 0240 00 00		.word	0
 713           		
 714           	current_lvl_dificult_in_time:
 715 0242 14 00		.word	20 
 716           		
 717           	score:
 718 0244 00 00		.word	0
 719           		
 720           	ticks:
 721 0246 00 00		.word	0		; uint16_t ticks;
 722           		
 723           	ball_pos:
 724 0248 80		.byte	0x80
 725           		
 726           	new_point_led:
 727 0249 00		.byte	0x00
 728           		
 729           	direction: ; 0 away from player 1 into the player
 730 024A 00		.byte	0x00
 731           	sw_state:
 732 024B 00		.byte 	0
 733           	; Seccao:    .bss
 734           	; Descricao: Guarda as variáveis globais sem valor inicial definido
 735           	;
 736           		.section .bss
 737           	outport_img:			; Imagem do porto de saida no programa
 738 024C 00   		.space	1	
 739           	
 740           	; Seccao:    .stack
 741           	; Descricao: Implementa a pilha com o tamanho definido pelo simbolo STACK_SIZE
 742           	;
 743           		.section .stack
 744 024E 00   		.space STACK_SIZE
 744 .... ..
 744 028D 00
 745           	tos:
